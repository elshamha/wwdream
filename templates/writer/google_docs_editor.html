{% extends 'base.html' %}
{% load static %}

{% block title %}Document Editor - A Writer's Web Dream{% endblock %}

{% block extra_head %}
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="cache-bust" content="{{ cache_bust }}">
{% endblock %}

{% block content %}

<!-- Mobile Detection and Redirect -->
<script>
(function() {
    // Detect if user is on a mobile device
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
               || (window.innerWidth <= 768);
    }
    
    // Check on page load
    if (isMobileDevice()) {
        // Prevent mobile users from using the editor
        document.addEventListener('DOMContentLoaded', function() {
            document.body.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 20px;">
                    <div style="text-align: center; max-width: 400px;">
                        <div style="font-size: 4rem; margin-bottom: 2rem;">
                            <i class="fas fa-mobile-alt" style="color: #667eea;"></i>
                        </div>
                        <h2 style="color: #ffffff; margin-bottom: 1rem;">Mobile Editor Coming Soon!</h2>
                        <p style="color: rgba(255, 255, 255, 0.8); margin-bottom: 2rem; line-height: 1.6;">
                            We're building a special mobile-friendly editor for phone users. 
                            The current editor is optimized for desktop use only.
                        </p>
                        <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 2rem;">
                            Please use a desktop computer to access the full editor, or wait for our upcoming mobile version.
                        </p>
                        <a href="{% url 'writer:dashboard' %}" class="btn btn-primary" style="padding: 12px 24px; border-radius: 10px;">
                            <i class="fas fa-arrow-left me-2"></i>Back to Dashboard
                        </a>
                    </div>
                </div>
            `;
        });
        return; // Stop executing the rest of the page
    }
})();
</script>

<!-- Desktop Editor Content (only shown on desktop) -->
{% csrf_token %}
<div class="docs-editor-container" id="desktop-editor">
    <!-- Chapter Sidebar -->
    <!-- New Chapter Manager -->
    <div class="new-chapter-manager" id="chapter-manager">
        <!-- Header -->
        <div class="chapter-header">
            <!-- Floating particles -->
            <div class="chapter-particles">
                <div class="chapter-particle"></div>
                <div class="chapter-particle"></div>
                <div class="chapter-particle"></div>
            </div>
            <div class="header-title">
                <i class="fas fa-book-open"></i>
                <span>Chapters</span>
                <span class="chapter-count" id="chapter-count">0</span>
            </div>
            <div class="header-controls">
                <button class="btn-icon" onclick="createNewChapter()" title="New Chapter">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="btn-icon" onclick="toggleChapterManager()" title="Toggle">
                    <i class="fas fa-chevron-left" id="manager-toggle-icon"></i>
                </button>
            </div>
        </div>

        <!-- Chapter Navigation -->
        <div class="chapter-navigation">
            <div class="nav-row">
                <label for="chapter-number-input">Go to Chapter:</label>
                <div class="chapter-input-group">
                    <input type="number" id="chapter-number-input" min="1" placeholder="1" class="chapter-number-input">
                    <button onclick="goToChapterByNumber()" class="btn-go" title="Go to Chapter">
                        <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>
            <div class="nav-row">
                <div class="chapter-nav-buttons">
                    <button onclick="previousChapter()" class="btn-nav" title="Previous Chapter">
                        <i class="fas fa-chevron-left"></i> Prev
                    </button>
                    <span class="current-chapter-info" id="current-chapter-info">No chapter selected</span>
                    <button onclick="nextChapter()" class="btn-nav" title="Next Chapter">
                        Next <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Chapter List -->
        <div class="chapter-list-container">
            <div class="chapter-list" id="chapter-list">
                <div class="empty-state" id="empty-chapters">
                    <i class="fas fa-book-open"></i>
                    <h3>No chapters yet</h3>
                    <p>Click + to create your first chapter</p>
                </div>
            </div>
        </div>

        <!-- Chapter Stats -->
        <div class="chapter-stats">
            <div class="stat-item">
                <span class="stat-value" id="total-chapters">0</span>
                <span class="stat-label">Chapters</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="total-words">0</span>
                <span class="stat-label">Words</span>
            </div>
        </div>
    </div>

    <!-- Main Editor Area -->
    <div class="docs-main-content" id="docs-main-content">
        <!-- Header -->
        <div class="docs-header">
        <div class="docs-header-content">
            <div class="docs-header-left">
                <div style="display: flex; align-items: center;">
                    <div class="docs-title-container" style="margin-left: 20px;">
                        <input type="text" id="document-title" class="docs-title-input" 
                               value="{% if current_chapter %}{{ current_chapter.title|default:'Untitled Chapter' }}{% else %}{{ document.title|default:'Untitled Document' }}{% endif %}" 
                               placeholder="{% if current_chapter %}Untitled Chapter{% else %}Untitled Document{% endif %}"
                               aria-label="Document title"
                               title="Edit document title">
                        <div class="docs-subtitle">{{ project.title|default:'Personal Document' }}</div>
                    </div>
                </div>
            </div>
            <div class="docs-header-right">
            <div class="docs-save-status" id="save-status">
                <i class="fas fa-check-circle"></i>
                <span>All changes saved</span>
            </div>
            <div class="docs-actions">
                <button class="docs-btn docs-btn-secondary" onclick="uploadDocument()" title="Upload Document">
                    <i class="fas fa-upload"></i>
                    Upload
                </button>

<script>
// Define essential functions first
function loadDocumentContent(data) {
    console.log('Loading document content:', data);
    
    // Wait for Quill to be ready
    const maxAttempts = 10;
    let attempts = 0;
    
    const tryLoadContent = () => {
        attempts++;
        console.log(`Attempt ${attempts} to load content`);
        
        // Check if Quill is available
        if (typeof window.quill !== 'undefined' && window.quill) {
            console.log('Quill editor found, loading content');
            
            try {
                // Use Quill's setText method to load content
                window.quill.setText(data.content || '');
                
                // Set document title
                if (data.title) {
                    const titleInput = document.getElementById('document-title');
                    if (titleInput) {
                        titleInput.value = data.title;
                        console.log('Document title set:', data.title);
                    }
                }
                
                // Show success notification
                if (typeof showNotification === 'function') {
                    showNotification('📄 Document loaded successfully!', 'success');
                } else {
                    console.log('Document loaded successfully!');
                }
                
                console.log('Content loaded successfully');
                return;
                
            } catch (error) {
                console.error('Error loading content with Quill:', error);
            }
        }
        
        // If Quill not ready and we haven't exceeded max attempts, try again
        if (attempts < maxAttempts) {
            console.log('Quill not ready, retrying in 500ms...');
            setTimeout(tryLoadContent, 500);
        } else {
            console.error('Could not load content - Quill editor not available after', maxAttempts, 'attempts');
            
            // Fallback: try direct DOM manipulation
            const editor = document.querySelector('.ql-editor');
            if (editor) {
                console.log('Fallback: using direct DOM manipulation');
                editor.innerHTML = '<p>' + (data.content || '').replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>') + '</p>';
            }
            
            showNotification('Document loaded (fallback method)', 'warning');
        }
    };
    
    // Start trying to load content
    tryLoadContent();
}

function showChapterDetectionDialog(data, file) {
    // Placeholder - will be replaced by the full function later
    console.log('Chapter detection dialog called with', data.chapters?.length, 'chapters');
    // For now, just load the content normally
    loadDocumentContent(data);
}

function showNotification(message, type = 'info') {
    // Simple early notification system
    console.log(`${type.toUpperCase()}: ${message}`);
    
    // Create a simple notification
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
        color: white;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
        notification.style.transform = 'translateX(300px)';
        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
            }
        }, 300);
    }, 3000);
}

// Upload function defined immediately after button
window.uploadDocument = function() {
    console.log('uploadDocument called');
    
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt,.doc,.docx,.pdf,.rtf,.odt';
    
    fileInput.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        console.log('File selected:', file.name);
        
        const formData = new FormData();
        formData.append('file', file);
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
        
        fetch('/writer/upload-to-editor/', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            console.log('Upload response:', data);
            if (data.success && data.content) {
                // Check if chapters were detected
                if (data.has_chapters && data.chapters && data.chapters.length > 1) {
                    showChapterDetectionDialog(data, file);
                } else {
                    // Load content normally
                    loadDocumentContent(data);
                }
            } else {
                showNotification('❌ Failed to upload document: ' + (data.error || 'Unknown error'), 'error');
            }
        })
        .catch(error => {
            console.error('Upload error:', error);
        });
    };
    
    fileInput.click();
};
console.log('uploadDocument function defined');
</script>
                <button class="docs-btn docs-btn-secondary" onclick="shareDocument()">
                    <i class="fas fa-share"></i>
                    Share
                </button>
                <button class="docs-btn docs-btn-secondary" onclick="exportToPDF()">
                    <i class="fas fa-file-pdf"></i>
                    Export PDF
                </button>
                <button class="docs-btn docs-btn-primary" onclick="saveDocument()">
                    <i class="fas fa-save"></i>
                    Save
                </button>
            </div>
        </div>
        </div>
    </div>

    <!-- Editor Container -->
    <div class="docs-editor-wrapper">

        <!-- Editor -->
        <div class="docs-editor-content">
            <div id="docs-editor" aria-label="Document editor" role="textbox" aria-multiline="true">
                <!-- Content will be loaded by JavaScript -->
            </div>
        </div>
    </div>
    </div> <!-- Close docs-main-content -->

    <!-- Footer Stats -->
    <div class="docs-footer">
        <div class="docs-stats">
            <!-- Stats removed -->
        </div>
        <div class="docs-footer-center">
            <!-- Page number display -->
            <div id="page-number-display" class="page-number-indicator" style="display: none;" onclick="showPageNavigationDialog()">
                Page <span id="footer-current-page">1</span> of <span id="footer-total-pages">1</span>
            </div>
        </div>
        <div class="docs-footer-right">
            <!-- Fullscreen button removed -->
        </div>
    </div>
    
    <!-- Chapter Navigator -->
    <div class="chapter-navigator" id="chapter-navigator">
        <button class="nav-btn" id="prev-chapter" onclick="navigateChapter(-1)" title="Previous Chapter">
            <i class="fas fa-chevron-left"></i>
        </button>
        <span id="chapter-indicator" style="color: #667eea; font-weight: 600; padding: 0 8px; font-size: 14px;">1/1</span>
        <button class="nav-btn" id="next-chapter" onclick="navigateChapter(1)" title="Next Chapter">
            <i class="fas fa-chevron-right"></i>
        </button>
    </div>
</div>

<!-- Share Modal -->
<div id="share-modal" class="docs-modal">
    <div class="docs-modal-content">
        <div class="docs-modal-header">
            <h3>Share Document</h3>
            <button class="docs-modal-close" onclick="closeShareModal()">&times;</button>
        </div>
        <div class="docs-modal-body">
            <div class="share-option">
                <label>Share with people</label>
                <div class="share-input-container">
                    <input type="email" placeholder="Enter email address" id="share-email">
                    <button class="docs-btn docs-btn-primary" onclick="addCollaborator()">Add</button>
                </div>
            </div>
            <div class="share-option">
                <label>Get shareable link</label>
                <div class="share-link-container">
                    <input type="text" readonly id="share-link" value="{{ request.build_absolute_uri|escape }}">
                    <button class="docs-btn docs-btn-secondary" onclick="copyShareLink()">Copy</button>
                </div>
            </div>
            <div class="collaborators-list" id="collaborators-list">
                <!-- Collaborators will be loaded here -->
            </div>
        </div>
    </div>
</div>

<style>
/* Google Docs-like Styling */
.docs-editor-container {
    background: #f8f9fa;
    min-height: 100vh;
    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
    display: flex;
    flex-direction: row;
}

/* Chapter Sidebar - Hidden */
.chapter-sidebar {
    display: none !important;
    /* Original styles preserved but hidden
    width: 300px;
    min-width: 300px;
    background: rgba(255, 255, 255, 0.95);
    border-right: 1px solid #e0e0e0;
    flex-direction: column;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
    z-index: 100;
    position: relative;
    */
}

.chapter-sidebar.collapsed {
    width: 50px;
    min-width: 50px;
    overflow: hidden;
}

.chapter-sidebar.collapsed .chapter-sidebar-header h4,
.chapter-sidebar.collapsed .chapter-list,
.chapter-sidebar.collapsed .chapter-sidebar-footer {
    opacity: 0;
    visibility: hidden;
}

.chapter-sidebar.collapsed .chapter-controls {
    flex-direction: column;
    gap: 4px;
}

.chapter-sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.chapter-sidebar-header h4 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: white !important;
}

.chapter-controls {
    display: flex;
    gap: 8px;
}

.btn-chapter-control {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 8px;
    padding: 8px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
}

.btn-chapter-control:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
}

.chapter-list {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    background: rgba(255, 255, 255, 0.5);
}

.chapter-item {
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.chapter-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-color: #667eea;
}

.chapter-item.active {
    border-color: #667eea;
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
}

.chapter-item.dragging {
    opacity: 0.5;
    transform: rotate(2deg);
}

.chapter-header {
    padding: 12px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.chapter-number {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 600;
    min-width: 28px;
    cursor: pointer;
}

.chapter-number.editing {
    background: #ff6b6b;
}

.chapter-number input {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    color: white;
    text-align: center;
    font-size: 12px;
    font-weight: 600;
    border-radius: 50%;
}

.chapter-info {
    flex: 1;
    min-width: 0;
}

.chapter-title {
    font-weight: 600;
    font-size: 14px;
    color: #333;
    margin-bottom: 4px;
    word-break: break-word;
}

.chapter-meta {
    font-size: 12px;
    color: #666;
    display: flex;
    gap: 12px;
}

.chapter-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.chapter-item:hover .chapter-actions {
    opacity: 1;
}

.btn-chapter-small {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
    transition: all 0.3s ease;
    font-size: 12px;
}

.btn-chapter-small:hover {
    background: #f0f0f0;
    color: #333;
}

.btn-chapter-small.danger:hover {
    background: #fff5f5;
    color: #e53e3e;
}

.chapter-drag-handle {
    color: #ccc;
    cursor: grab;
    padding: 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.chapter-item:hover .chapter-drag-handle {
    opacity: 1;
}

.chapter-drag-handle:active {
    cursor: grabbing;
}

.chapter-sidebar-footer {
    padding: 8px 10px;
    border-top: 1px solid #e0e0e0;
    background: white;
}

.btn-chapter-action {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 14px;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-chapter-action:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

/* New Chapter Manager - Hidden by default */
#chapter-manager.new-chapter-manager {
    display: none !important;
    /* Original styles preserved but hidden
    width: 280px !important;
    min-width: 280px !important;
    background: rgba(255, 255, 255, 0.8) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 255, 255, 0.15) !important;
    border-radius: 16px 0 0 16px !important;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 4px rgba(0, 0, 0, 0.03) !important;
    flex-direction: column;
    height: calc(100vh - 20px) !important;
    position: relative;
    z-index: 100;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    opacity: 0.95 !important;
    transform: scale(0.98) !important;
    margin: 10px 0 !important;
    border-right: none !important;
    */
}

#chapter-manager.new-chapter-manager:hover {
    opacity: 1 !important;
    transform: scale(1) !important;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1), 0 3px 8px rgba(0, 0, 0, 0.06) !important;
}

/* Chapter Manager Collapsed State */
.new-chapter-manager.collapsed {
    width: 50px;
    min-width: 50px;
}

/* Chapter Header */
.chapter-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
}

.chapter-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="%23ffffff" opacity="0.05"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>') repeat;
    pointer-events: none;
}

.header-title {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 16px;
    font-weight: 600;
    z-index: 1;
    position: relative;
}

.header-title i {
    font-size: 18px;
    opacity: 0.9;
    animation: chapterIconBreathe 4s ease-in-out infinite;
}

/* Breathing animation for chapter icon */
@keyframes chapterIconBreathe {
    0%, 100% { 
        transform: scale(1);
        opacity: 0.9;
    }
    50% { 
        transform: scale(1.1);
        opacity: 1;
    }
}

.chapter-count {
    background: rgba(255, 255, 255, 0.2);
    padding: 4px 10px;
    border-radius: 15px;
    font-size: 12px;
    font-weight: 500;
    backdrop-filter: blur(10px);
    animation: chapterCountPulse 3s ease-in-out infinite;
}

/* Floating particles for chapter manager */
.chapter-particles {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    overflow: hidden;
    z-index: 0;
}

.chapter-particle {
    position: absolute;
    background: rgba(102, 126, 234, 0.1);
    border-radius: 50%;
    animation: chapterParticleFloat 6s ease-in-out infinite;
}

.chapter-particle:nth-child(1) {
    width: 4px;
    height: 4px;
    left: 10%;
    top: 20%;
    animation-delay: 0s;
}

.chapter-particle:nth-child(2) {
    width: 3px;
    height: 3px;
    left: 80%;
    top: 60%;
    animation-delay: 2s;
}

.chapter-particle:nth-child(3) {
    width: 5px;
    height: 5px;
    left: 60%;
    top: 40%;
    animation-delay: 4s;
}

@keyframes chapterParticleFloat {
    0%, 100% { 
        transform: translateY(0px) rotate(0deg);
        opacity: 0.3;
    }
    50% { 
        transform: translateY(-10px) rotate(180deg);
        opacity: 0.6;
    }
}

@keyframes chapterCountPulse {
    0%, 100% { 
        transform: scale(1);
    }
    50% { 
        transform: scale(1.05);
    }
}

.header-controls {
    display: flex;
    gap: 10px;
    z-index: 1;
    position: relative;
}

.btn-icon {
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
}

.btn-icon:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

/* Chapter Navigation */
.chapter-navigation {
    padding: 20px;
    background: rgba(248, 249, 250, 0.8);
    border-bottom: 1px solid #e8eaed;
}

.nav-row {
    margin-bottom: 15px;
}

.nav-row:last-child {
    margin-bottom: 0;
}

.nav-row label {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
}

.chapter-input-group {
    display: flex;
    gap: 10px;
    align-items: center;
}

.chapter-number-input {
    flex: 1;
    padding: 10px 12px;
    border: 2px solid #e8eaed;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    background: white;
    transition: all 0.3s ease;
}

.chapter-number-input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.btn-go {
    padding: 10px 15px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
}

.btn-go:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.chapter-nav-buttons {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}

.btn-nav {
    padding: 10px 15px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    color: #495057;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
    font-size: 13px;
    min-width: 80px;
}

.btn-nav:hover {
    background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
    transform: translateY(-1px);
}

.btn-nav:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.current-chapter-info {
    font-size: 12px;
    color: #667eea;
    font-weight: 600;
    text-align: center;
    flex: 1;
    padding: 0 10px;
}

/* Chapter List */
.chapter-list-container {
    flex: 1;
    overflow-y: auto;
    padding: 10px 0;
}

.chapter-list {
    padding: 0 15px;
}

.chapter-item {
    display: flex;
    align-items: center;
    padding: 12px;
    margin-bottom: 8px;
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    transform: translateY(0);
}
}

.chapter-item:hover {
    transform: translateY(-2px) scale(1.01);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.15), 0 3px 8px rgba(0, 0, 0, 0.08);
    border-color: rgba(102, 126, 234, 0.3);
    background: rgba(255, 255, 255, 0.85);
}

.chapter-item.active {
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.05);
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
}

.chapter-item.active::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 4px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 0 2px 2px 0;
}

.chapter-number {
    width: 32px;
    height: 32px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 14px;
    margin-right: 12px;
    flex-shrink: 0;
    animation: chapterNumberGlow 3s ease-in-out infinite;
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

@keyframes chapterNumberGlow {
    0%, 100% { 
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }
    50% { 
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }
}

.chapter-info {
    flex: 1;
    min-width: 0;
}

.chapter-title {
    font-weight: 600;
    font-size: 14px;
    color: #333;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chapter-meta {
    font-size: 12px;
    color: #6c757d;
    display: flex;
    gap: 15px;
}

.chapter-actions {
    opacity: 0;
    transition: opacity 0.3s ease;
    display: flex;
    gap: 5px;
}

.chapter-item:hover .chapter-actions {
    opacity: 1;
}

.action-btn-sm {
    width: 24px;
    height: 24px;
    border: none;
    background: #f8f9fa;
    color: #6c757d;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 12px;
}

.action-btn-sm:hover {
    background: #e9ecef;
    color: #495057;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: #9aa0a6;
}

.empty-state i {
    font-size: 48px;
    margin-bottom: 16px;
    opacity: 0.5;
}

.empty-state h3 {
    margin: 0 0 8px 0;
    font-size: 18px;
    color: #5f6368;
}

.empty-state p {
    margin: 0;
    font-size: 14px;
}

/* Chapter Stats */
.chapter-stats {
    padding: 15px;
    background: rgba(248, 249, 250, 0.8);
    border-top: 1px solid #e8eaed;
    display: flex;
    justify-content: space-around;
}

.stat-item {
    text-align: center;
}

.stat-value {
    display: block;
    font-size: 18px;
    font-weight: 700;
    color: #667eea;
    margin-bottom: 2px;
}

.stat-label {
    font-size: 12px;
    color: #6c757d;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Collapsed State */
.new-chapter-manager.collapsed .chapter-navigation,
.new-chapter-manager.collapsed .chapter-list-container,
.new-chapter-manager.collapsed .chapter-stats,
.new-chapter-manager.collapsed .header-title span:not(.chapter-count) {
    display: none;
}

/* ===== FLOATING COMPANION TOOLBAR STYLES ===== */
.floating-companion {
    position: fixed;
    right: 20px;
    top: 100px;
    width: 200px;
    z-index: 90;
    opacity: 0.7;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    transform: scale(0.9);
}

.floating-companion:hover {
    opacity: 0.95;
    transform: scale(0.95);
}

.companion-body {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 16px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 4px rgba(0, 0, 0, 0.03);
    overflow: hidden;
    position: relative;
}

.companion-header {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.8) 0%, rgba(118, 75, 162, 0.8) 100%);
    color: white;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
    overflow: hidden;
}

.companion-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="dots" width="10" height="10" patternUnits="userSpaceOnUse"><circle cx="5" cy="5" r="1" fill="%23ffffff" opacity="0.1"/></pattern></defs><rect width="100" height="100" fill="url(%23dots)"/></svg>') repeat;
    pointer-events: none;
}

.companion-avatar {
    font-size: 16px;
    z-index: 1;
    animation: avatarBreathe 4s ease-in-out infinite;
}

.companion-title {
    font-weight: 600;
    font-size: 13px;
    flex: 1;
    z-index: 1;
    color: white !important;
}

.companion-minimize {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 50%;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 1;
    font-size: 10px;
}

.companion-minimize:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.companion-content {
    padding: 10px;
    max-height: 350px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #ccc transparent;
}

.companion-content::-webkit-scrollbar {
    width: 4px;
}

.companion-content::-webkit-scrollbar-track {
    background: transparent;
}

.companion-content::-webkit-scrollbar-thumb {
    background: #ccc;
    border-radius: 2px;
}

.companion-section {
    margin-bottom: 12px;
    animation: sectionFadeIn 0.3s ease-out;
}

.section-title {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 11px;
    color: #444;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.section-title i {
    color: #667eea;
    font-size: 12px;
}

.companion-btn {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 11px;
    font-weight: 500;
    position: relative;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(232, 234, 237, 0.6);
}

.companion-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* Format tools */
.format-tools {
    display: flex;
    gap: 4px;
    margin-bottom: 6px;
}

.format-btn {
    width: 26px;
    height: 26px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid rgba(102, 126, 234, 0.3);
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.9);
    cursor: pointer;
    transition: all 0.3s ease;
    color: #202124;
    font-size: 12px;
    font-weight: 600;
}

.format-btn:hover {
    background: #f8f9fa;
    border-color: #667eea;
    color: #667eea;
    transform: scale(1.1);
}

.format-btn:active {
    transform: scale(0.95);
    background: #667eea;
    color: white;
}

/* Override any white text in floating companion - make it black */
.floating-companion .stat-number, 
.floating-companion .badge, 
.floating-companion .btn, 
.floating-companion .form-control, 
.floating-companion .card-text, 
.floating-companion .fas, 
.floating-companion .far, 
.floating-companion .fab,
.floating-companion *:not(.format-btn):not(.format-btn *):not(.companion-title) {
    color: #000000 !important;
}

.selection-info {
    background: rgba(248, 249, 250, 0.7);
    border-radius: 8px;
    padding: 8px;
    margin-top: 6px;
}

.selection-stats {
    display: flex;
    gap: 16px;
    margin-bottom: 8px;
}

.stat-item {
    text-align: center;
}

.stat-value {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: #667eea;
}

.stat-label {
    font-size: 9px;
    color: #5f6368;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.selection-preview {
    background: rgba(255, 255, 255, 0.8);
    padding: 6px 8px;
    border-radius: 6px;
    border: 1px solid rgba(232, 234, 237, 0.5);
    font-size: 10px;
    color: #5f6368;
    line-height: 1.3;
    min-height: 16px;
}

.companion-mood {
    background: linear-gradient(135deg, rgba(248, 249, 250, 0.8) 0%, rgba(233, 236, 239, 0.8) 100%);
    padding: 8px 10px;
    display: flex;
    align-items: center;
    gap: 6px;
    border-top: 1px solid rgba(232, 234, 237, 0.5);
}

.mood-face {
    font-size: 14px;
    animation: moodBounce 3s ease-in-out infinite;
}

.mood-text {
    font-size: 10px;
    font-weight: 500;
    color: #5f6368;
}

.floating-companion.minimized .companion-content,
.floating-companion.minimized .companion-mood {
    display: none;
}

.floating-companion.minimized .companion-body {
    border-radius: 20px 20px 20px 20px;
}

/* Animations */
@keyframes avatarBreathe {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

@keyframes sectionFadeIn {
    0% {
        opacity: 0;
        transform: translateY(10px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes moodBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-2px); }
}

/* Chapter Detection Styles */
.detection-preview {
    background: rgba(248, 249, 250, 0.8);
    border-radius: 6px;
    padding: 8px;
    border: 1px solid rgba(232, 234, 237, 0.5);
}

.detected-chapter {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    margin-bottom: 3px;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 4px;
    font-size: 10px;
    border: 1px solid rgba(102, 126, 234, 0.2);
}

.chapter-marker {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    font-weight: 600;
    flex-shrink: 0;
}

.chapter-preview-title {
    font-weight: 500;
    color: #333;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
}

.chapter-preview-words {
    color: #666;
    font-size: 9px;
    margin-left: auto;
}

.detection-actions .companion-btn {
    margin-bottom: 0 !important;
}

/* Chapter highlighting in editor */
.chapter-highlight {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border-left: 3px solid #667eea;
    padding: 2px 4px;
    margin: 2px 0;
    border-radius: 0 4px 4px 0;
    position: relative;
}

.chapter-highlight::before {
    content: '📖';
    position: absolute;
    left: -15px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    opacity: 0.7;
}

/* ===== END FLOATING COMPANION TOOLBAR STYLES ===== */

/* Main Content Area - Full Width */
.docs-main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    width: 100% !important;
    margin-left: 0 !important;
    min-width: 0;
}

.docs-header {
    background: white;
    border-bottom: 1px solid #e0e0e0;
    padding: 12px 24px;
    position: sticky;
    top: 0;
    z-index: 100;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}

.docs-header-content {
    max-width: 1000px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 30px;
}

.docs-title-container {
    display: flex;
    flex-direction: column;
}

.docs-title-input {
    border: none;
    outline: none;
    font-size: 18px;
    font-weight: 400;
    color: #000000;
    background: transparent;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
    text-align: left;
}

.docs-title-input:hover {
    background: #f1f3f4;
}

.docs-title-input:focus {
    background: white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
}

.docs-subtitle {
    font-size: 12px;
    color: #5f6368;
    margin-left: 8px;
}

.docs-header-left {
    display: flex;
    align-items: center;
    flex: 0 0 auto;
}

.docs-header-right {
    display: flex;
    align-items: center;
    gap: 16px;
    flex: 0 0 auto;
}

.docs-save-status {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: #5f6368;
}

.docs-save-status.saving {
    color: #1a73e8;
}

.docs-save-status.error {
    color: #d93025;
}

.docs-actions {
    display: flex;
    gap: 8px;
}

.docs-btn {
    background: transparent;
    border: 1px solid #dadce0;
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
}

.docs-btn:hover {
    background: #f8f9fa;
    border-color: #bdc1c6;
}

.docs-btn-primary {
    background: #1a73e8;
    border-color: #1a73e8;
    color: white;
}

.docs-btn-primary:hover {
    background: #1557b0;
}

.docs-btn-secondary {
    background: white;
    color: #1a73e8;
}

.docs-btn-link {
    border: none;
    color: #1a73e8;
    background: transparent;
}

.docs-editor-wrapper {
    max-width: none;
    width: 100%;
    margin: 0;
    background: white;
    box-shadow: 0 2px 10px rgba(0,0,0,0.12);
    min-height: calc(100vh - 120px);
    flex: 1;
}


.docs-editor-content {
    padding: 0;
    min-height: 600px;
    display: flex;
    justify-content: flex-start;
    background: #f0f0f0;
}

#docs-editor {
    /* MLA Standard Page Size: 8.5" x 11" */
    width: 8.5in;
    min-height: 11in;
    max-width: 8.5in;
    
    /* MLA Standard Margins: 1 inch on all sides */
    padding: 1in;
    margin: 20px auto;
    
    /* MLA Standard Font and Spacing */
    font-family: 'Times New Roman', Times, serif;
    font-size: 12pt;
    line-height: 2.0; /* Double-spaced */
    color: #000000;
    
    /* Page appearance */
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    
    /* Print-like appearance */
    border: 1px solid #ddd;
}

/* Chapter Detection Highlight */
.chapter-highlight {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
    border-left: 4px solid #667eea;
    margin: 10px 0;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    position: relative;
}

.chapter-highlight::after {
    content: "Click to create chapter";
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #667eea;
    font-weight: 600;
}

.chapter-highlight:hover {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.3) 0%, rgba(118, 75, 162, 0.3) 100%);
}

/* Chapter Pagination Styles */
.chapter-break {
    page-break-before: always;
    break-before: page;
    border-top: 3px solid #667eea;
    margin-top: 2rem;
    padding-top: 2rem;
    position: relative;
}

.chapter-break::before {
    content: "Chapter " attr(data-chapter-number);
    position: absolute;
    top: -1.5rem;
    left: 0;
    background: white;
    padding: 0 1rem;
    font-weight: bold;
    font-size: 14px;
    color: #667eea;
}

.chapter-title-display {
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 1rem;
    text-align: center;
}

/* Print styles for proper pagination */
@media print {
    .chapter-break {
        page-break-before: always;
        break-before: page;
    }
    
    .modern-chapter-manager {
        display: none;
    }
    
}

/* Enhanced Chapter Navigation */
.chapter-navigator {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 50px;
    padding: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    display: flex;
    gap: 8px;
    z-index: 1000;
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.3s ease;
}

.chapter-navigator.visible {
    opacity: 1;
    transform: translateY(0);
}

.nav-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: #667eea;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.nav-btn:hover {
    background: #5a6fd8;
    transform: scale(1.1);
}

.nav-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
}

.docs-footer {
    background: white;
    border-top: 1px solid #e0e0e0;
    padding: 8px 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #5f6368;
    position: sticky;
    bottom: 0;
}

.docs-footer-center {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
}

.page-number-indicator {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    padding: 6px 12px;
    border-radius: 15px;
    font-size: 12px;
    font-weight: 600;
    border: 1px solid rgba(102, 126, 234, 0.2);
    transition: all 0.3s ease;
    cursor: pointer;
}

.page-number-indicator:hover {
    background: rgba(102, 126, 234, 0.15);
    transform: scale(1.05);
}

/* Chapter Detection Modal Styles */
.chapter-detection-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
    animation: modalFadeIn 0.3s ease-out;
}

.chapter-dialog-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
}

.chapter-dialog-content {
    position: relative;
    background: white;
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    max-width: 900px;
    max-height: 80vh;
    width: 95%;
    overflow: hidden;
    animation: modalSlideIn 0.4s ease-out;
}

.chapter-dialog-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.chapter-dialog-header h3 {
    margin: 0;
    font-size: 1.3em;
    display: flex;
    align-items: center;
    gap: 10px;
}

.chapter-dialog-close {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    padding: 8px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.chapter-dialog-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.chapter-dialog-body {
    padding: 20px;
    max-height: 60vh;
    overflow-y: auto;
}

.chapter-detection-summary {
    background: rgba(102, 126, 234, 0.05);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 20px;
    border-left: 4px solid #667eea;
}

.confidence-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
    font-size: 0.9em;
}

.confidence-bar {
    flex: 1;
    height: 6px;
    background: rgba(102, 126, 234, 0.1);
    border-radius: 3px;
    overflow: hidden;
}

.confidence-fill {
    height: 100%;
    background: linear-gradient(90deg, #667eea, #764ba2);
    transition: width 0.6s ease;
    border-radius: 3px;
}

.chapter-preview-list h4 {
    color: #333;
    margin-bottom: 15px;
    font-size: 1.1em;
}

.chapter-items {
    max-height: 300px;
    overflow-y: auto;
    padding-right: 5px;
}

.chapter-preview-item {
    background: white;
    border: 1px solid rgba(102, 126, 234, 0.1);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 10px;
    transition: all 0.3s ease;
}

.chapter-preview-item:hover {
    border-color: rgba(102, 126, 234, 0.3);
    box-shadow: 0 2px 10px rgba(102, 126, 234, 0.1);
}

.chapter-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.chapter-header strong {
    color: #333;
    font-size: 1em;
}

.chapter-stats {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.8em;
    font-weight: 600;
}

.chapter-preview-content {
    color: #666;
    font-size: 0.9em;
    line-height: 1.4;
    font-style: italic;
}

.chapter-actions {
    margin-top: 25px;
    padding-top: 20px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.action-group {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
}

.chapter-btn {
    flex: 1;
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.chapter-btn.primary {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
}

.chapter-btn.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
}

.chapter-btn.secondary {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    border: 2px solid rgba(102, 126, 234, 0.2);
}

.chapter-btn.secondary:hover {
    background: rgba(102, 126, 234, 0.15);
    border-color: rgba(102, 126, 234, 0.3);
}

.action-note {
    text-align: center;
    color: #666;
    font-size: 0.85em;
}

.action-note i {
    color: #667eea;
    margin-right: 5px;
}

@keyframes modalFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

/* Detected Chapters Styles */
.detected-chapters-header {
    margin-bottom: 15px;
    padding: 12px;
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border-radius: 10px;
    border-left: 4px solid #667eea;
}

.detection-notice {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 12px;
    font-weight: 600;
    color: #667eea;
}

.detection-notice i {
    font-size: 14px;
    animation: sparkle 2s ease-in-out infinite alternate;
}

.detection-stats {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(102, 126, 234, 0.1);
    color: #999;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.detection-stats small {
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 4px;
}

.detection-stats small::before {
    content: '🤖';
    font-size: 12px;
}

.create-chapters-btn {
    background: linear-gradient(135deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 11px;
    margin-left: auto;
}

.create-chapters-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.chapter-item-modern.detected-chapter {
    border-left: 3px solid #667eea;
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.02) 0%, rgba(118, 75, 162, 0.02) 100%);
    position: relative;
}

.chapter-item-modern.detected-chapter::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.03) 0%, rgba(118, 75, 162, 0.03) 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.chapter-item-modern.detected-chapter:hover::before {
    opacity: 1;
}

.chapter-number-modern.detected-number {
    position: relative;
}

.confidence-indicator {
    position: absolute;
    bottom: 2px;
    right: 2px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.chapter-meta-modern {
    display: flex;
    gap: 8px;
    margin-top: 4px;
    font-size: 11px;
    opacity: 1 !important;
}

.chapter-meta-modern span {
    background: rgba(102, 126, 234, 0.1);
    color: #667eea;
    padding: 2px 6px;
    border-radius: 8px;
    font-weight: 500;
}

.detection-method {
    background: rgba(76, 175, 80, 0.1) !important;
    color: #4caf50 !important;
}

.confidence-score {
    background: rgba(255, 152, 0, 0.1) !important;
    color: #ff9800 !important;
}

.chapter-preview {
    font-size: 11px;
    color: #666 !important;
    font-style: italic;
    margin-top: 6px;
    line-height: 1.3;
    opacity: 1 !important;
    max-height: 26px;
    overflow: hidden;
}

.chapter-actions-modern .split-btn {
    background: linear-gradient(135deg, #4caf50, #45a049);
    color: white;
}

.chapter-actions-modern .split-btn:hover {
    background: linear-gradient(135deg, #45a049, #3d8b40);
    transform: scale(1.1);
}

.single-document-view {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px;
    background: rgba(102, 126, 234, 0.05);
    border-radius: 10px;
    border: 2px dashed rgba(102, 126, 234, 0.2);
}

.document-info {
    display: flex;
    align-items: center;
    gap: 15px;
}

.document-info i {
    font-size: 2rem;
    color: #667eea;
    opacity: 0.7;
}

.document-details h4 {
    margin: 0 0 4px 0;
    color: #333;
    font-size: 14px;
}

.document-details p {
    margin: 0 0 2px 0;
    color: #667eea;
    font-weight: 600;
    font-size: 12px;
}

.document-details small {
    color: #999;
    font-size: 10px;
}

@keyframes sparkle {
    0%, 100% { 
        transform: scale(1);
        opacity: 0.7;
    }
    50% { 
        transform: scale(1.2);
        opacity: 1;
    }
}

/* Loading state for chapter detection */
.chapter-detection-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    background: rgba(102, 126, 234, 0.05);
    border-radius: 10px;
    border: 2px dashed rgba(102, 126, 234, 0.2);
}

.loading-content {
    text-align: center;
    color: #667eea;
}

.loading-content i {
    font-size: 2rem;
    margin-bottom: 10px;
    animation: spin 1s linear infinite;
}

.loading-content h4 {
    margin: 0 0 8px 0;
    font-size: 14px;
}

.loading-content p {
    margin: 0;
    font-size: 12px;
    color: #999;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Enhanced chapter item active state for detected chapters */
.chapter-item-modern.detected-chapter.active {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    border-left-color: #764ba2;
    border-left-width: 4px;
}

/* Animate chapter navigation */
.chapter-item-modern.detected-chapter.navigating {
    animation: chapterPulse 0.6s ease-in-out;
}

@keyframes chapterPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); box-shadow: 0 4px 20px rgba(102, 126, 234, 0.2); }
}

.docs-stats {
    display: flex;
    gap: 16px;
}

/* Quill Editor Customization */

.ql-container.ql-snow {
    border: none !important;
    font-size: inherit !important;
}

.ql-editor {
    font-family: 'Times New Roman', Times, serif !important;
    font-size: 12pt !important;
    line-height: 2.0 !important; /* Double-spaced */
    color: #000000 !important;
    padding: 0 !important;
    text-align: left !important;
}

.ql-editor * {
    color: #000000 !important;
    font-family: 'Times New Roman', Times, serif !important;
}

.ql-editor p, .ql-editor div, .ql-editor span, .ql-editor h1, .ql-editor h2, .ql-editor h3, .ql-editor h4, .ql-editor h5, .ql-editor h6, .ql-editor li, .ql-editor blockquote {
    color: #000000 !important;
    font-family: 'Times New Roman', Times, serif !important;
    line-height: 2.0 !important;
}

.ql-editor.ql-blank::before {
    color: #5f6368 !important;
    font-style: italic;
}

.ql-editor h1 {
    font-size: 12pt;
    font-weight: normal;
    margin: 0;
    text-align: left;
    line-height: 2.0 !important;
}

.ql-editor h2 {
    font-size: 12pt;
    font-weight: normal;
    margin: 0;
    line-height: 2.0 !important;
}

.ql-editor h3 {
    font-size: 12pt;
    font-weight: normal;
    margin: 0;
    line-height: 2.0 !important;
}

.ql-editor p {
    margin: 0;
    line-height: 2.0 !important;
    text-indent: 0.5in; /* MLA paragraph indent */
    font-weight: normal !important;
    text-align: left !important;
}

/* Ensure all text defaults to normal formatting */
.ql-editor {
    font-weight: normal !important;
    text-align: left !important;
}

.ql-editor > * {
    font-weight: normal !important;
    text-align: left !important;
}

.ql-editor p:first-child {
    text-indent: 0; /* No indent for first paragraph */
}

.ql-editor blockquote {
    background: none;
    border: none;
    margin: 0;
    padding: 0;
    margin-left: 1in; /* MLA block quote indent */
    margin-right: 1in;
    font-style: normal;
    line-height: 2.0 !important;
}

.ql-editor ul, .ql-editor ol {
    margin: 0;
    padding-left: 0.5in;
    line-height: 2.0 !important;
}

.ql-editor li {
    line-height: 2.0 !important;
    margin: 0;
}


/* Modal Styles */
.docs-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
}

.docs-modal-content {
    background: white;
    margin: 10% auto;
    padding: 0;
    border-radius: 8px;
    width: 500px;
    max-width: 90%;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}

.docs-modal-header {
    padding: 24px 24px 0 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.docs-modal-header h3 {
    margin: 0;
    font-size: 20px;
    font-weight: 400;
}

.docs-modal-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #5f6368;
}

.docs-modal-body {
    padding: 24px;
}

.share-option {
    margin-bottom: 24px;
}

.share-option label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: #202124;
}

.share-input-container,
.share-link-container {
    display: flex;
    gap: 8px;
}

.share-input-container input,
.share-link-container input {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #dadce0;
    border-radius: 4px;
    font-size: 14px;
}

/* Responsive Design */
@media (max-width: 768px) {
    .docs-header {
        padding: 8px 16px;
        flex-direction: column;
        gap: 12px;
    }

    .docs-editor-wrapper {
        margin: 0 8px;
    }

    .docs-editor-content {
        padding: 16px 8px;
        background: white;
    }

    #docs-editor {
        width: 100%;
        max-width: 100%;
        min-height: 500px;
        padding: 0.5in;
        margin: 0;
        box-shadow: none;
        border: none;
    }

}

@media print {
    .docs-header,
    .docs-footer {
        display: none !important;
    }
    
    .docs-editor-wrapper {
        box-shadow: none !important;
        margin: 0 !important;
        max-width: none !important;
    }
    
    .docs-editor-content {
        background: white !important;
        padding: 0 !important;
    }
    
    #docs-editor {
        box-shadow: none !important;
        border: none !important;
        margin: 0 !important;
        width: 100% !important;
        max-width: none !important;
    }
}

/* Animation Classes */
.saving-animation {
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Full Screen Mode */
.fullscreen-mode {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 10000;
    background: white;
}

.fullscreen-mode .docs-editor-wrapper {
    max-width: none;
    height: 100vh;
    margin: 0;
    box-shadow: none;
}

.fullscreen-mode .docs-editor-content {
    height: calc(100vh - 160px);
    overflow-y: auto;
}
</style>

<!-- Include Quill.js -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

<script>
// Global variables
let quill;
let currentDocumentId = {% if current_chapter %}{{ current_chapter.id }}{% elif document and document.id %}{{ document.id }}{% else %}null{% endif %};
let projectId = {% if project %}{{ project.id }}{% else %}null{% endif %};
let currentChapterId = {% if current_chapter %}{{ current_chapter.id }}{% else %}null{% endif %};
let autoSaveTimeout;
let lastSavedContent = '';

// Essential functions that need to be available early (updated version)
function loadDocumentContent(data) {
    console.log('Loading document content (main function):', data);
    
    // Use Quill API if available
    if (typeof quill !== 'undefined' && quill) {
        try {
            // Use Quill's setText method
            quill.setText(data.content || '');
            console.log('Content loaded with Quill API');
        } catch (error) {
            console.error('Error using Quill API:', error);
            // Fallback to DOM manipulation
            const editor = document.querySelector('.ql-editor');
            if (editor) {
                editor.innerHTML = '<p>' + (data.content || '').replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>') + '</p>';
            }
        }
    } else {
        console.log('Quill not available, using DOM manipulation');
        // Fallback to DOM manipulation
        const editor = document.querySelector('.ql-editor');
        if (editor) {
            editor.innerHTML = '<p>' + (data.content || '').replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>') + '</p>';
        }
    }
    
    // Set document title
    if (data.title) {
        const titleInput = document.getElementById('document-title');
        if (titleInput) titleInput.value = data.title;
        console.log('Document title set:', data.title);
    }
    
    // Use our notification system
    showNotification('📄 Document loaded successfully!', 'success');
    
    // Auto-center titles if enabled
    if (typeof autoCenteringEnabled !== 'undefined' && autoCenteringEnabled) {
        setTimeout(() => {
            if (typeof autoCenterTitles === 'function') {
                autoCenterTitles();
            }
        }, 500);
    }
}
let chapters = [
    {% if all_chapters %}
        {% for chapter in all_chapters %}
        {
            id: {{ chapter.id }},
            title: "{{ chapter.title|escapejs }}",
            content: "{{ chapter.content|escapejs }}",
            order: {{ chapter.order }},
            created_at: "{{ chapter.created_at|date:'c' }}",
            last_edited: "{{ chapter.last_edited|date:'c' }}"
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    {% endif %}
];
let sidebarCollapsed = false;
let chapterDetectionEnabled = false; // Disabled for better performance

// Pagination variables
let paginationEnabled = false; // Pagination permanently disabled
let currentPage = 1;
let totalPages = 1;
let mlaCharactersPerPage = 2850; // Approximately 250 words per page in MLA format
let pages = [];

// Version control variables
let versionHistory = [];
let currentVersion = null;

// Enhanced Chapter Navigation and Pagination Functions
function navigateChapter(direction) {
    if (!chapters.length) return;
    
    const currentIndex = chapters.findIndex(c => c.id === currentChapterId);
    let newIndex = currentIndex + direction;
    
    if (newIndex < 0) newIndex = chapters.length - 1;
    if (newIndex >= chapters.length) newIndex = 0;
    
    if (chapters[newIndex]) {
        openChapter(chapters[newIndex].id);
    }
}

function updateChapterNavigator() {
    const navigator = document.getElementById('chapter-navigator');
    const indicator = document.getElementById('chapter-indicator');
    const prevBtn = document.getElementById('prev-chapter');
    const nextBtn = document.getElementById('next-chapter');
    
    if (!chapters.length) {
        navigator.classList.remove('visible');
        return;
    }
    
    navigator.classList.add('visible');
    
    const currentIndex = chapters.findIndex(c => c.id === currentChapterId);
    const currentNum = currentIndex + 1;
    const totalChapters = chapters.length;
    
    indicator.textContent = currentNum + '/' + totalChapters;
    
    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = currentIndex === chapters.length - 1;
}

function addPaginationToContent() {
    if (!quill || !chapters.length) return;
    
    const content = quill.root;
    const existingBreaks = content.querySelectorAll('.chapter-break');
    existingBreaks.forEach(br => br.remove());
    
    // Add chapter breaks and titles based on detected chapters
    const headings = content.querySelectorAll('h1, h2, .chapter-highlight');
    let chapterNumber = 1;
    
    headings.forEach((heading, index) => {
        if (index > 0) { // Don't add break before first chapter
            const chapterBreak = document.createElement('div');
            chapterBreak.className = 'chapter-break';
            chapterBreak.setAttribute('data-chapter-number', chapterNumber);
            
            heading.parentNode.insertBefore(chapterBreak, heading);
            chapterNumber++;
        }
        
        // Add chapter title styling if it's a heading
        if (heading.tagName && (heading.tagName.toLowerCase() === 'h1' || heading.tagName.toLowerCase() === 'h2')) {
            heading.classList.add('chapter-title-display');
        }
    });
}

function enhancedOpenChapter(chapterId) {
    if (!chapterId) return;
    
    // Save current chapter before switching
    if (currentChapterId && quill) {
        saveDocument(false);
    }
    
    const chapter = chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    
    // Update current chapter
    currentChapterId = chapterId;
    currentDocumentId = chapterId;
    
    // Load chapter content
    if (quill && chapter.content) {
        const cleanedContent = cleanContentForQuill(chapter.content);
        if (cleanedContent.includes('<')) {
            quill.root.innerHTML = cleanedContent;
        } else {
            quill.setText(cleanedContent);
        }
    }
    
    // Update document title
    const titleInput = document.getElementById('document-title');
    if (titleInput) {
        titleInput.value = chapter.title || 'Untitled Chapter';
    }
    
    // Update active chapter in sidebar
    document.querySelectorAll('.chapter-item').forEach(item => {
        item.classList.remove('active');
    });
    
    const activeItem = document.querySelector('[data-chapter-id="' + chapterId + '"]');
    if (activeItem) {
        activeItem.classList.add('active');
    }
    
    // Update navigator and pagination
    updateChapterNavigator();
    setTimeout(() => {
        addPaginationToContent();
        updateWordCount();
    }, 100);
    
    // Update URL without page reload
    const newUrl = window.location.pathname.replace(/\/chapters\/\d+/, '') + '/chapters/' + chapterId;
    window.history.pushState({chapterId}, '', newUrl);
}

function enhancedReorderChapter(fromIndex, toIndex) {
    if (fromIndex === toIndex) return;
    
    // Update local chapter array
    const [movedChapter] = chapters.splice(fromIndex, 1);
    chapters.splice(toIndex, 0, movedChapter);
    
    // Renumber chapters
    chapters.forEach((chapter, index) => {
        chapter.order = index + 1;
    });
    
    // Update server
    const orderData = chapters.map((chapter, index) => ({ 
        id: chapter.id, 
        order: index + 1 
    }));
    
    fetch('/writer/chapters/reorder/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({ chapters: orderData })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            renderChapterList();
            updateChapterNavigator();
            showNotification('Chapter order updated!', 'success');
        } else {
            showNotification('Error updating chapter order', 'error');
            loadChapters(); // Reload to reset
        }
    })
    .catch(error => {
        console.error('Error reordering chapters:', error);
        showNotification('Error updating chapter order', 'error');
        loadChapters(); // Reload to reset
    });
}

// Initialize the editor
document.addEventListener('DOMContentLoaded', function() {
    // Check if Quill is loaded
    if (typeof Quill === 'undefined') {
        console.error('Quill.js failed to load from CDN');
        document.getElementById('docs-editor').innerHTML = '<div style="padding: 20px; color: red; background: white; border: 1px solid red;">Error: Quill.js editor failed to load. Please refresh the page or check your internet connection.</div>';
        return;
    }
    
    console.log('Quill.js loaded successfully');
    initializeEditor();
    setupAutoSave();
    setupEventListeners();
    
    // Initialize modern chapter manager instead of old loadChapters
    // loadChapters(); // Replaced by modern chapter manager
    
    // Delay word count update to ensure quill is ready
    setTimeout(updateWordCount, 500);
    
    // Initialize modern chapter manager
    setTimeout(() => {
        loadModernChapters();
        updateChapterCount();
    }, 300);
    setTimeout(initializeModernChapterManager, 100);
});

// HTML sanitization helper
function sanitizeHTML(html) {
    // Create a temporary div to parse HTML
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    // Remove script tags and other dangerous elements
    const scripts = temp.querySelectorAll('script, iframe, object, embed');
    scripts.forEach(el => el.remove());
    
    // Return cleaned HTML
    return temp.innerHTML;
}

// Clean and format content for Quill
function cleanContentForQuill(content) {
    if (!content) return '';
    
    // If content looks like HTML (has tags)
    if (content.includes('<') && content.includes('>')) {
        // Create a temporary div to parse HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = sanitizeHTML(content);
        
        // Remove any H1 headings at the beginning that might be redundant titles
        const firstElement = tempDiv.firstElementChild;
        if (firstElement && firstElement.tagName === 'H1') {
            // Get the current document title to compare
            const currentTitle = document.getElementById('document-title')?.value;
            const h1Text = firstElement.textContent.trim();
            
            // Remove H1 if it matches the document title or looks like a generic chapter title
            if (currentTitle && h1Text === currentTitle) {
                firstElement.remove();
            } else if (h1Text.match(/^Chapter\s+\d+/i) || h1Text.match(/^Untitled/i)) {
                firstElement.remove();
            }
        }
        
        return tempDiv.innerHTML;
    }
    
    // Otherwise treat as plain text
    return content.replace(/&lt;/g, '<')
                  .replace(/&gt;/g, '>')
                  .replace(/&amp;/g, '&')
                  .replace(/&quot;/g, '"')
                  .replace(/&#39;/g, "'");
}

function initializeEditor() {
    try {
        console.log('Initializing Quill editor...');
        
        // Check if editor element exists
        const editorElement = document.getElementById('docs-editor');
        
        if (!editorElement) {
            console.error('Editor element #docs-editor not found');
            return;
        }
        
        console.log('Elements found, initializing Quill...');
        
        // Initialize Quill without toolbar - using floating companion instead
        quill = new Quill('#docs-editor', {
            theme: 'snow',
            modules: {
                toolbar: false,
                history: {
                    delay: 1000,
                    maxStack: 500,
                    userOnly: true
                }
            },
            formats: [
                'header', 'font', 'size',
                'bold', 'italic', 'underline', 'strike',
                'color', 'background',
                'align', 'list', 'indent',
                'blockquote', 'code-block',
                'link', 'image', 'video', 'formula'
            ]
        });
        
        console.log('Quill editor initialized successfully');
        
        // Ensure editor starts with normal paragraph formatting
        quill.format('header', false);
        quill.format('bold', false);
        quill.format('align', false);
        
        // Add event listener to prevent unwanted formatting
        quill.on('selection-change', function(range) {
            if (range && range.length === 0) {
                // When cursor is positioned, ensure normal formatting
                quill.format('header', false);
                quill.format('bold', false);
                quill.format('align', false);
            }
        });
        
        // Set initial content after Quill is initialized
        {% if current_chapter and current_chapter.content %}
            console.log('Loading chapter content...');
            try {
                const content = '{{ current_chapter.content|escapejs }}';
                if (content && content.trim()) {
                    const cleanedContent = cleanContentForQuill(content);
                    if (cleanedContent.includes('<')) {
                        quill.root.innerHTML = cleanedContent;
                    } else {
                        quill.setText(cleanedContent);
                    }
                }
            } catch (e) {
                console.error('Error loading chapter content:', e);
            }
        {% elif document and document.content %}
            console.log('Loading document content...');
            try {
                const content = '{{ document.content|escapejs }}';
                if (content && content.trim()) {
                    const cleanedContent = cleanContentForQuill(content);
                    if (cleanedContent.includes('<')) {
                        quill.root.innerHTML = cleanedContent;
                    } else {
                        quill.setText(cleanedContent);
                    }
                }
            } catch (e) {
                console.error('Error loading document content:', e);
            }
        {% endif %}
        
        // Initialize pagination and version control after content is loaded
        setTimeout(() => {
            console.log('Initializing pagination and version control...');
            
            // Debug: Check if companion exists
            const companion = document.querySelector('.floating-companion');
            const paginationSection = document.getElementById('pagination-section');
            console.log('Companion found:', !!companion);
            console.log('Pagination section found:', !!paginationSection);
            
            // Auto-center existing titles
            if (autoCenteringEnabled) {
                setTimeout(() => {
                    autoCenterTitles();
                    console.log('Auto-centered existing titles');
                }, 500);
            }
            
            if (quill.getText().length > mlaCharactersPerPage * 2) {
                // Auto-enable pagination for long documents
                if (paginationSection) {
                    paginationSection.style.background = 'rgba(255, 193, 7, 0.1)';
                    paginationSection.style.border = '2px solid rgba(255, 193, 7, 0.4)';
                    setTimeout(() => {
                        paginationSection.style.background = '';
                        paginationSection.style.border = '';
                    }, 3000);
                }
                // Pagination popup removed
            }
            
            // Always show a welcome message with pagination info
            setTimeout(() => {
                showCompanionNotification('📝 Editor ready - Normal formatting mode enabled.', 'info');
            }, 2000);
            
            // Load version history
            refreshVersionList();
            updatePageInfo();
            
            // Highlight the companion briefly to show where it is
            if (companion) {
                companion.style.transform = 'scale(1.05)';
                companion.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.3)';
                setTimeout(() => {
                    companion.style.transform = '';
                    companion.style.boxShadow = '';
                }, 2000);
            }
        }, 1500);
        
    } catch (error) {
        console.error('Error initializing Quill editor:', error);
    }

    // Add undo/redo buttons functionality
    const undoButton = document.querySelector('.ql-undo');
    const redoButton = document.querySelector('.ql-redo');
    
    if (undoButton) {
        undoButton.addEventListener('click', function() {
            quill.history.undo();
        });
    }
    
    if (redoButton) {
        redoButton.addEventListener('click', function() {
            quill.history.redo();
        });
    }

    // Debounce timers
    let wordCountDebounce = null;
    let savingStatusDebounce = null;
    
    // Listen for content changes with debouncing
    quill.on('text-change', function(delta, oldDelta, source) {
        if (source === 'user') {
            // Debounce word count updates (only update after 500ms of no typing)
            clearTimeout(wordCountDebounce);
            wordCountDebounce = setTimeout(() => {
                updateWordCount();
            }, 500);
            
            // Debounce saving status (only show after 1000ms of typing)
            clearTimeout(savingStatusDebounce);
            savingStatusDebounce = setTimeout(() => {
                showSavingStatus();
            }, 1000);
            
            scheduleAutoSave();
            
            // Update pagination if enabled (heavily debounced)
            if (paginationEnabled) {
                clearTimeout(window.paginationDebounce);
                window.paginationDebounce = setTimeout(() => {
                    calculatePages();
                    updatePageInfo();
                }, 2000); // Only update pagination after 2 seconds of no typing
            }
            
            // Auto-center titles if enabled
            if (autoCenteringEnabled) {
                debouncedAutoCenterTitles();
            }
            
            // Re-detect chapters after content changes
            debouncedChapterDetection();
            
            // Check for performance optimizations
            debouncedOptimizePerformance();
            
            // Smart chapter creation is now handled in the header toolbar handler
            // checkForSmartChapterCreation(delta);
        }
    });
    
    // Listen for paste events for auto-chapter detection
    quill.root.addEventListener('paste', function(e) {
        // Chapter detection disabled for better performance
        // setTimeout(() => {
        //     if (chapterDetectionEnabled) {
        //         detectChapters();
        //     }
        // }, 100);
    });
    
    // Initialize innovative chapter creation systems
    // initializeFloatingActionBubble(); // Disabled - no dropdown on selection
    initializeFloatingCompanion();

    // Auto-focus the editor so users can start typing immediately
    setTimeout(() => {
        if (quill) {
            quill.focus();
            // Place cursor at the end of existing content
            const length = quill.getLength();
            quill.setSelection(length - 1, 0);
        }
    }, 500);

    // Initial content is now loaded in initializeEditor()
}

function setupAutoSave() {
    // Auto-save every 30 seconds
    setInterval(function() {
        const currentContent = quill.root.innerHTML;
        if (currentContent !== lastSavedContent) {
            saveDocument(false);
        }
    }, 30000);
}

function setupEventListeners() {
    // Document title change
    document.getElementById('document-title').addEventListener('input', function() {
        scheduleAutoSave();
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
            switch(e.key) {
                case 's':
                    e.preventDefault();
                    saveDocument();
                    break;
                case 'z':
                    if (e.shiftKey) {
                        e.preventDefault();
                        quill.history.redo();
                    } else {
                        e.preventDefault();
                        quill.history.undo();
                    }
                    break;
            }
        }
        
        if (e.key === 'F11') {
            e.preventDefault();
            toggleFullscreen();
        }
    });
}

function scheduleAutoSave() {
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(function() {
        saveDocument(false);
    }, 2000);
}

function updateWordCount() {
    if (!quill) {
        console.warn('Quill not initialized, cannot update word count');
        return;
    }
    
    try {
        // Use requestAnimationFrame for smooth UI updates
        requestAnimationFrame(() => {
            const text = quill.getText();
            // More efficient word counting
            const words = text.trim() ? text.trim().match(/\S+/g)?.length || 0 : 0;
            const chars = text.length;
        
        const wordCountElement = document.getElementById('word-count');
        const charCountElement = document.getElementById('char-count');
        const pageCountElement = document.getElementById('page-count');
        
        if (wordCountElement) {
            wordCountElement.textContent = words + ' words';
        }
        
        if (charCountElement) {
            charCountElement.textContent = chars + ' characters';
        }
        
        if (pageCountElement) {
            // Estimate page count (roughly 250 words per page)
            const pages = Math.max(1, Math.ceil(words / 250));
            pageCountElement.textContent = 'Page ' + pages;
        }
        });
    } catch (error) {
        console.error('Error updating word count:', error);
    }
}

function showSavingStatus() {
    const statusElement = document.getElementById('save-status');
    statusElement.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i><span>Saving...</span>';
    statusElement.className = 'docs-save-status saving saving-animation';
}

function showSavedStatus() {
    const statusElement = document.getElementById('save-status');
    statusElement.innerHTML = '<i class="fas fa-check-circle"></i><span>All changes saved</span>';
    statusElement.className = 'docs-save-status';
}

function showErrorStatus() {
    const statusElement = document.getElementById('save-status');
    statusElement.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>Error saving</span>';
    statusElement.className = 'docs-save-status error';
}

function updateSaveStatus(status, message) {
    const statusElement = document.getElementById('save-status');
    
    switch(status) {
        case 'uploading':
        case 'saving':
            statusElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>' + message + '</span>';
            statusElement.className = 'docs-save-status saving';
            break;
        case 'saved':
            statusElement.innerHTML = '<i class="fas fa-check-circle"></i><span>' + message + '</span>';
            statusElement.className = 'docs-save-status saved';
            break;
        case 'error':
            statusElement.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>' + message + '</span>';
            statusElement.className = 'docs-save-status error';
            break;
        default:
            statusElement.innerHTML = '<i class="fas fa-check-circle"></i><span>All changes saved</span>';
            statusElement.className = 'docs-save-status';
    }
}

function saveDocument(showNotification = true) {
    if (!quill) {
        console.error('Quill not initialized, cannot save document');
        return;
    }
    
    try {
        const title = document.getElementById('document-title').value;
        const content = quill.root.innerHTML;
    
    if (showNotification) {
        showSavingStatus();
    }
    
    const formData = new FormData();
    formData.append('action', 'save_chapter');
    formData.append('title', title);
    formData.append('content', content);
    if (currentChapterId) {
        formData.append('chapter_id', currentChapterId);
    }
    if (currentDocumentId) {
        formData.append('document_id', currentDocumentId);
    }
    formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch(window.location.href, {
        method: 'POST',
        body: formData,
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('HTTP error! status: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        console.log('Save response:', data);
        if (data.status === 'success' || data.success) {
            lastSavedContent = content;
            
            // Update document ID if a new document was created
            if (data.document_id && !currentDocumentId) {
                currentDocumentId = data.document_id;
                // Update the URL if needed
                if (window.history && window.history.replaceState) {
                    const newUrl = '/writer/docs-editor/' + data.document_id + '/';
                    window.history.replaceState({}, '', newUrl);
                }
            }
            
            showSavedStatus();
            if (showNotification) {
                showNotification(data.message || 'Chapter saved successfully!', 'success');
            }
            // Update chapter ID if a new chapter was created
            if (data.chapter_id && !currentChapterId) {
                currentChapterId = data.chapter_id;
            }
        } else {
            showErrorStatus();
            if (showNotification) {
                showNotification('Error saving chapter: ' + (data.error || data.message || 'Unknown error'), 'error');
            }
        }
    })
    .catch(error => {
        console.error('Save error:', error);
        showErrorStatus();
        if (showNotification) {
            showNotification('Error saving document. Please try again.', 'error');
        }
    });
    
    } catch (error) {
        console.error('Error in saveDocument:', error);
        showErrorStatus();
        if (showNotification) {
            showNotification('Error preparing document save. Please try again.', 'error');
        }
    }
}

window.uploadDocument = function() {
    console.log('uploadDocument function called');
    // Create a file input element
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.txt,.doc,.docx,.pdf,.rtf,.odt';
    
    fileInput.onchange = async function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        // Show loading status
        updateSaveStatus('uploading', 'Uploading document...');
        
        // Create FormData for file upload
        const formData = new FormData();
        formData.append('file', file);
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
        
        try {
            const response = await fetch('/writer/upload-to-editor/', {
                method: 'POST',
                body: formData
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Load the content into the editor
                if (data.content) {
                    // Convert plain text to proper HTML paragraphs
                    const htmlContent = data.content.split('\n\n').map(paragraph => 
                        paragraph.trim() ? '<p>' + paragraph.replace(/\n/g, '<br>') + '</p>' : '<p><br></p>'
                    ).join('');
                    quill.root.innerHTML = htmlContent;
                }
                
                // Update the title if provided
                if (data.title) {
                    document.getElementById('document-title').value = data.title;
                }
                
                updateSaveStatus('saved', 'Document uploaded successfully');
                
                // Auto-save after upload
                setTimeout(() => saveDocument(), 1000);
            } else {
                updateSaveStatus('error', data.message || 'Upload failed');
            }
        } catch (error) {
            console.error('Upload error:', error);
            updateSaveStatus('error', 'Failed to upload document');
        }
    };
    
    // Trigger file selection
    fileInput.click();
}

function shareDocument() {
    document.getElementById('share-modal').style.display = 'block';
    loadCollaborators();
}

function exportToPDF() {
    // Check if we have a current chapter
    if (currentChapterId) {
        // Export current chapter as PDF
        window.location.href = `/writer/chapters/${currentChapterId}/export-pdf/`;
    } else if (projectId) {
        // Export entire project as PDF
        window.location.href = `/writer/projects/${projectId}/export-pdf/`;
    } else if (currentDocumentId) {
        // Export document as PDF
        window.location.href = `/writer/documents/${currentDocumentId}/export-pdf/`;
    } else {
        showNotification('Please save your work before exporting to PDF', 'warning');
    }
}

function closeShareModal() {
    document.getElementById('share-modal').style.display = 'none';
}

function addCollaborator() {
    const email = document.getElementById('share-email').value;
    if (!email) return;
    
    // API call to add collaborator
    fetch('/writer/documents/' + currentDocumentId + '/share/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({ email: email })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            document.getElementById('share-email').value = '';
            loadCollaborators();
            showNotification('Collaborator added successfully!', 'success');
        } else {
            showNotification(data.error || 'Error adding collaborator', 'error');
        }
    });
}

function loadCollaborators() {
    if (!currentDocumentId) return;
    
    fetch('/writer/documents/' + currentDocumentId + '/collaborators/')
    .then(response => response.json())
    .then(data => {
        const collaboratorsList = document.getElementById('collaborators-list');
        collaboratorsList.innerHTML = '';
        
        if (data.collaborators && data.collaborators.length > 0) {
            const header = document.createElement('h4');
            header.textContent = 'People with access';
            header.style.marginTop = '24px';
            header.style.marginBottom = '12px';
            collaboratorsList.appendChild(header);
            
            data.collaborators.forEach(collaborator => {
                const item = document.createElement('div');
                item.className = 'collaborator-item';
                item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #e0e0e0;';
                item.innerHTML = 
                    '<span>' + collaborator.email + '</span>' +
                    '<button class="docs-btn docs-btn-link" onclick="removeCollaborator(\'' + collaborator.id + '\')">Remove</button>';
                collaboratorsList.appendChild(item);
            });
        }
    });
}

function copyShareLink() {
    const shareLink = document.getElementById('share-link');
    shareLink.select();
    document.execCommand('copy');
    showNotification('Link copied to clipboard!', 'success');
}

function toggleFullscreen() {
    const container = document.querySelector('.docs-editor-container');
    
    if (container.classList.contains('fullscreen-mode')) {
        container.classList.remove('fullscreen-mode');
        document.querySelector('[onclick="toggleFullscreen()"] i').className = 'fas fa-expand';
    } else {
        container.classList.add('fullscreen-mode');
        document.querySelector('[onclick="toggleFullscreen()"] i').className = 'fas fa-compress';
    }
}

function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = 
        'position: fixed;' +
        'top: 20px;' +
        'right: 20px;' +
        'padding: 12px 20px;' +
        'border-radius: 4px;' +
        'color: white;' +
        'font-size: 14px;' +
        'z-index: 10000;' +
        'animation: slideIn 0.3s ease;';
    
    switch(type) {
        case 'success':
            notification.style.background = '#4caf50';
            break;
        case 'error':
            notification.style.background = '#f44336';
            break;
        default:
            notification.style.background = '#2196f3';
    }
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 3000);
}

// Add CSS for animations
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(style);

// New Chapter Management Functions
let currentChapterIndex = -1;

function loadChapters() {
    if (!projectId) return;
    
    fetch('/writer/projects/' + projectId + '/chapters/list/')
        .then(response => response.json())
        .then(data => {
            chapters = data.chapters || [];
            renderChapterList();
            updateChapterInfo();
            updateChapterStats();
        })
        .catch(error => {
            console.error('Error loading chapters:', error);
        });
}

function renderChapterList() {
    const chapterList = document.getElementById('chapter-list');
    const emptyState = document.getElementById('empty-chapters');
    
    if (chapters.length === 0) {
        chapterList.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    emptyState.style.display = 'none';
    chapterList.innerHTML = '';
    
    chapters.forEach((chapter, index) => {
        const chapterItem = document.createElement('div');
        chapterItem.className = 'chapter-item' + (currentChapterId === chapter.id ? ' active' : '');
        chapterItem.setAttribute('data-chapter-id', chapter.id);
        chapterItem.setAttribute('data-chapter-index', index);
        
        chapterItem.innerHTML = `
            <div class="chapter-number">${index + 1}</div>
            <div class="chapter-info">
                <div class="chapter-title">${chapter.title || 'Untitled Chapter'}</div>
                <div class="chapter-meta">
                    <span><i class="fas fa-font"></i> ${chapter.word_count || 0} words</span>
                    <span><i class="fas fa-clock"></i> ${formatDate(chapter.updated_at)}</span>
                </div>
            </div>
            <div class="chapter-actions">
                <button class="action-btn-sm" onclick="editChapter(${chapter.id})" title="Edit">
                    <i class="fas fa-edit"></i>
                </button>
                <button class="action-btn-sm" onclick="deleteChapter(${chapter.id})" title="Delete">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        
        chapterItem.addEventListener('click', (e) => {
            if (!e.target.closest('.chapter-actions')) {
                goToChapter(chapter.id, index);
            }
        });
        
        chapterList.appendChild(chapterItem);
    });
}

function goToChapterByNumber() {
    const input = document.getElementById('chapter-number-input');
    const chapterNumber = parseInt(input.value);
    
    if (!chapterNumber || chapterNumber < 1 || chapterNumber > chapters.length) {
        showNotification('Invalid chapter number. Please enter a number between 1 and ' + chapters.length, 'error');
        return;
    }
    
    const chapterIndex = chapterNumber - 1;
    const chapter = chapters[chapterIndex];
    
    if (chapter) {
        goToChapter(chapter.id, chapterIndex);
        input.value = '';
    }
}

function goToChapter(chapterId, index) {
    currentChapterId = chapterId;
    currentChapterIndex = index;
    
    // Update UI
    updateChapterList();
    updateChapterInfo();
    loadChapterContent(chapterId);
    
    showNotification(`Switched to Chapter ${index + 1}: ${chapters[index].title || 'Untitled'}`, 'success');
}

function previousChapter() {
    if (currentChapterIndex <= 0) {
        showNotification('Already at the first chapter', 'info');
        return;
    }
    
    const prevIndex = currentChapterIndex - 1;
    const prevChapter = chapters[prevIndex];
    goToChapter(prevChapter.id, prevIndex);
}

function nextChapter() {
    if (currentChapterIndex >= chapters.length - 1) {
        showNotification('Already at the last chapter', 'info');
        return;
    }
    
    const nextIndex = currentChapterIndex + 1;
    const nextChapter = chapters[nextIndex];
    goToChapter(nextChapter.id, nextIndex);
}

function updateChapterList() {
    const chapterItems = document.querySelectorAll('.chapter-item');
    chapterItems.forEach((item, index) => {
        if (index === currentChapterIndex) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

function updateChapterInfo() {
    const infoElement = document.getElementById('current-chapter-info');
    const prevBtn = document.querySelector('.btn-nav:first-child');
    const nextBtn = document.querySelector('.btn-nav:last-child');
    
    if (currentChapterIndex >= 0 && chapters[currentChapterIndex]) {
        const current = chapters[currentChapterIndex];
        infoElement.textContent = `Chapter ${currentChapterIndex + 1}: ${current.title || 'Untitled'}`;
        
        prevBtn.disabled = currentChapterIndex <= 0;
        nextBtn.disabled = currentChapterIndex >= chapters.length - 1;
    } else {
        infoElement.textContent = 'No chapter selected';
        prevBtn.disabled = true;
        nextBtn.disabled = true;
    }
}

function updateChapterStats() {
    const totalChapters = document.getElementById('total-chapters');
    const totalWords = document.getElementById('total-words');
    const chapterCount = document.getElementById('chapter-count');
    
    totalChapters.textContent = chapters.length;
    chapterCount.textContent = chapters.length;
    
    const wordCount = chapters.reduce((total, chapter) => total + (chapter.word_count || 0), 0);
    totalWords.textContent = wordCount.toLocaleString();
}

function loadChapterContent(chapterId) {
    if (!quill) return;
    
    // Show loading state
    quill.enable(false);
    
    fetch(`/writer/chapters/${chapterId}/`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Update editor with chapter content
                const content = data.content || '';
                quill.setContents(JSON.parse(content || '[]'));
                quill.enable(true);
                
                // Update document title
                const titleInput = document.getElementById('document-title');
                if (titleInput) {
                    titleInput.value = data.title || 'Untitled Chapter';
                }
            } else {
                showNotification('Error loading chapter: ' + (data.error || 'Unknown error'), 'error');
                quill.enable(true);
            }
        })
        .catch(error => {
            console.error('Error loading chapter:', error);
            showNotification('Error loading chapter content', 'error');
            quill.enable(true);
        });
}

// Handle Enter key in chapter number input
document.addEventListener('DOMContentLoaded', function() {
    const chapterInput = document.getElementById('chapter-number-input');
    if (chapterInput) {
        chapterInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                goToChapterByNumber();
            }
        });
    }
});

// Toggle chapter manager
function toggleChapterManager() {
    const chapterManager = document.getElementById('chapter-manager');
    const toggleIcon = document.getElementById('manager-toggle-icon');
    
    chapterManager.classList.toggle('collapsed');
    
    if (chapterManager.classList.contains('collapsed')) {
        toggleIcon.className = 'fas fa-chevron-right';
    } else {
        toggleIcon.className = 'fas fa-chevron-left';
    }
}

// Show notification helper
function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
        color: white;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        transform: translateX(300px);
        transition: all 0.3s ease;
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 10);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
        notification.style.transform = 'translateX(300px)';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// Create new chapter
function createNewChapter() {
    if (!projectId) {
        showNotification('No project selected', 'error');
        return;
    }
    
    const title = prompt('Enter chapter title:');
    if (!title) return;
    
    fetch('/writer/chapters/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({
            project_id: projectId,
            title: title,
            content: '[]'
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            loadChapters(); // Reload the chapter list
            showNotification(`Chapter "${title}" created successfully`, 'success');
        } else {
            showNotification('Error creating chapter: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter:', error);
        showNotification('Error creating chapter', 'error');
    });
}

function detectChapters() {
    // Chapter detection completely disabled for better performance
    return;
    // if (!quill) return;
    
    const content = quill.root;
    
    // Remove existing highlights
    const existingHighlights = content.querySelectorAll('.chapter-highlight');
    existingHighlights.forEach(highlight => {
        const parent = highlight.parentNode;
        while (highlight.firstChild) {
            parent.insertBefore(highlight.firstChild, highlight);
        }
        parent.removeChild(highlight);
    });
    
    // Enhanced chapter detection patterns
    const chapterPatterns = [
        /(Chapter\s+\d+[:\s]|Chapter\s+[A-Za-z]+[:\s]|CHAPTER\s+\d+[:\s]|CHAPTER\s+[A-Za-z]+[:\s])/gi,
        /(Part\s+\d+[:\s]|Part\s+[A-Za-z]+[:\s]|PART\s+\d+[:\s]|PART\s+[A-Za-z]+[:\s])/gi,
        /(\d+\.\s+[A-Z][a-z\s]{5,30})/g, // Numbered headings like "1. The Beginning"
    ];
    
    // Find H2 headings and large text
    const headings = content.querySelectorAll('h1, h2, h3');
    headings.forEach(heading => {
        if (heading.tagName.toLowerCase() === 'h2' || 
            (heading.tagName.toLowerCase() === 'h1' && heading.textContent.length > 5)) {
            highlightPotentialChapter(heading, heading.textContent.trim());
        }
    });
    
    // Find elements with large font sizes (AI-like detection)
    const allElements = content.querySelectorAll('*');
    allElements.forEach(element => {
        const style = window.getComputedStyle(element);
        const fontSize = parseFloat(style.fontSize);
        const fontWeight = style.fontWeight;
        const textContent = element.textContent.trim();
        
        // AI logic: Large font (>18px) OR bold text with decent length
        if ((fontSize > 18 || fontWeight === 'bold' || fontWeight >= 600) && 
            textContent.length > 5 && textContent.length < 100 &&
            !element.classList.contains('chapter-highlight') &&
            element.children.length === 0) { // Only text nodes, no nested elements
            
            // Check if it's likely a chapter heading
            if (isLikelyChapterHeading(textContent)) {
                highlightPotentialChapter(element, textContent);
            }
        }
    });
    
    // Find text patterns in all text nodes
    const textNodes = getTextNodes(content);
    textNodes.forEach(node => {
        const text = node.textContent;
        
        chapterPatterns.forEach(regex => {
            const matches = text.match(regex);
            if (matches) {
                matches.forEach(match => {
                    const index = text.indexOf(match);
                    if (index !== -1) {
                        // Check bounds to prevent IndexSizeError
                        const nodeLength = node.textContent.length;
                        const startIndex = Math.min(index, nodeLength);
                        const endIndex = Math.min(index + match.length, nodeLength);
                        
                        if (startIndex < nodeLength && endIndex <= nodeLength) {
                            try {
                                const range = document.createRange();
                                range.setStart(node, startIndex);
                                range.setEnd(node, endIndex);
                                
                                const highlight = document.createElement('span');
                                highlight.className = 'chapter-highlight';
                                highlight.setAttribute('data-chapter-text', match.trim());
                                highlight.addEventListener('click', function() {
                                    createChapterFromHighlight(this.getAttribute('data-chapter-text'));
                                });
                                
                                range.surroundContents(highlight);
                            } catch (e) {
                                console.log('Could not highlight chapter heading:', match);
                            }
                        }
                    }
                });
            }
        });
    });
}

function getTextNodes(node) {
    let textNodes = [];
    
    if (node.nodeType === Node.TEXT_NODE) {
        textNodes.push(node);
    } else {
        for (let child of node.childNodes) {
            textNodes = textNodes.concat(getTextNodes(child));
        }
    }
    
    return textNodes;
}

function isLikelyChapterHeading(text) {
    const chapterKeywords = [
        /chapter/i, /part/i, /section/i, /book/i, /episode/i,
        /prologue/i, /epilogue/i, /introduction/i, /conclusion/i,
        /^\d+\.\s/,  // Starts with number and period
        /^[IVXLC]+\.\s/i,  // Roman numerals
    ];
    
    // Check for chapter keywords
    const hasKeywords = chapterKeywords.some(pattern => pattern.test(text));
    
    // Check for title case (multiple capital letters)
    const capitalWords = (text.match(/\b[A-Z][a-z]+/g) || []).length;
    const totalWords = text.split(/\s+/).length;
    const isTitleCase = capitalWords / totalWords > 0.5;
    
    // Likely a heading if it has keywords OR is title case with reasonable length
    return hasKeywords || (isTitleCase && totalWords >= 2 && totalWords <= 8);
}

function highlightPotentialChapter(element, text) {
    // Chapter highlighting completely disabled for better performance
    return;
    // if (element.classList.contains('chapter-highlight')) return;
    
    // element.classList.add('chapter-highlight');
    // element.setAttribute('data-chapter-text', text);
    // element.style.cursor = 'pointer';
    // element.addEventListener('click', function() {
    //     createChapterFromHighlight(this.getAttribute('data-chapter-text'));
    // });
}

function createChapterFromHighlight(chapterTitle) {
    if (!projectId) {
        showNotification('Chapter creation is only available when editing within a project', 'info');
        console.log('No project context - chapter creation disabled');
        return;
    }
    
    console.log('Creating chapter:', chapterTitle, 'for project:', projectId);
    
    const formData = new FormData();
    formData.append('title', chapterTitle);
    formData.append('content', '');
    formData.append('project', projectId);
    formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log('Chapter creation response:', data);
        if (data.success) {
            showNotification('Chapter created successfully!', 'success');
            loadChapters();
        } else {
            showNotification('Error creating chapter: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter:', error);
        showNotification('Error creating chapter', 'error');
    });
}

function toggleChapterSidebar() {
    const sidebar = document.getElementById('chapter-sidebar');
    const icon = document.getElementById('sidebar-toggle-icon');
    
    sidebarCollapsed = !sidebarCollapsed;
    
    if (sidebarCollapsed) {
        sidebar.classList.add('collapsed');
        icon.className = 'fas fa-chevron-right';
    } else {
        sidebar.classList.remove('collapsed');
        icon.className = 'fas fa-chevron-left';
    }
}

function addNewChapter() {
    const title = prompt('Enter chapter title:');
    if (!title || !projectId) return;
    
    const formData = new FormData();
    formData.append('title', title);
    formData.append('content', '');
    formData.append('project', projectId);
    formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Chapter created successfully!', 'success');
            loadChapters();
        } else {
            showNotification('Error creating chapter', 'error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter:', error);
        showNotification('Error creating chapter', 'error');
    });
}

function editChapterNumber(chapterId, currentNumber) {
    const chapterItem = document.querySelector('[data-chapter-id="' + chapterId + '"]');
    const numberDisplay = chapterItem.querySelector('.chapter-num-display');
    const numberInput = chapterItem.querySelector('.chapter-num-input');
    
    numberDisplay.style.display = 'none';
    numberInput.style.display = 'block';
    numberInput.focus();
    numberInput.select();
    
    const saveNumber = () => {
        const newNumber = parseInt(numberInput.value);
        if (newNumber > 0 && newNumber <= chapters.length && newNumber !== currentNumber) {
            reorderChapter(chapterId, newNumber - 1);
        }
        numberDisplay.style.display = 'block';
        numberInput.style.display = 'none';
    };
    
    numberInput.addEventListener('blur', saveNumber);
    numberInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            saveNumber();
        } else if (e.key === 'Escape') {
            numberInput.value = currentNumber;
            numberDisplay.style.display = 'block';
            numberInput.style.display = 'none';
        }
    });
}

function reorderChapter(chapterId, newIndex) {
    const currentIndex = chapters.findIndex(c => c.id === chapterId);
    if (currentIndex === -1 || currentIndex === newIndex) return;
    
    // Move chapter in local array
    const [movedChapter] = chapters.splice(currentIndex, 1);
    chapters.splice(newIndex, 0, movedChapter);
    
    // Update order on server
    const orderData = chapters.map((chapter, index) => ({ id: chapter.id, order: index + 1 }));
    
    fetch('/writer/chapters/reorder/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({ chapters: orderData })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            renderChapterList();
            showNotification('Chapter order updated!', 'success');
        } else {
            // Revert local changes
            loadChapters();
            showNotification('Error updating chapter order', 'error');
        }
    })
    .catch(error => {
        console.error('Error reordering chapters:', error);
        loadChapters(); // Reload from server
        showNotification('Error updating chapter order', 'error');
    });
}

function openChapter(chapterId) {
    if (projectId) {
        window.location.href = '/writer/projects/' + projectId + '/chapters/' + chapterId + '/edit/';
    }
}

function editChapter(chapterId) {
    openChapter(chapterId);
}

function deleteChapter(chapterId) {
    if (!confirm('Are you sure you want to delete this chapter?')) return;
    
    fetch('/writer/chapters/' + chapterId + '/delete/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Chapter deleted successfully!', 'success');
            loadChapters();
        } else {
            showNotification('Error deleting chapter', 'error');
        }
    })
    .catch(error => {
        console.error('Error deleting chapter:', error);
        showNotification('Error deleting chapter', 'error');
    });
}

function saveChapterOrder() {
    const orderData = chapters.map((chapter, index) => ({ id: chapter.id, order: index + 1 }));
    
    fetch('/writer/chapters/reorder/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({ chapters: orderData })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Chapter order saved!', 'success');
        } else {
            showNotification('Error saving chapter order', 'error');
        }
    })
    .catch(error => {
        console.error('Error saving chapter order:', error);
        showNotification('Error saving chapter order', 'error');
    });
}

function setupChapterDetection() {
    // Chapter detection disabled - this function is now a no-op
    return;
}

// ===== MODERN CHAPTER MANAGER FUNCTIONS =====

let searchTimeout;
let currentView = 'list';

function initializeModernChapterManager() {
    // Set up search functionality
    const searchInput = document.getElementById('chapter-search');
    if (searchInput) {
        searchInput.addEventListener('input', handleChapterSearch);
        searchInput.addEventListener('focus', () => {
            const container = document.querySelector('.search-container');
            if (container) container.style.transform = 'scale(1.02)';
        });
        searchInput.addEventListener('blur', () => {
            const container = document.querySelector('.search-container');
            if (container) container.style.transform = 'scale(1)';
        });
    }

    // Set up view toggle buttons
    const viewButtons = document.querySelectorAll('.view-btn');
    viewButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            viewButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentView = btn.dataset.view;
            renderModernChapterList();
        });
    });

    // Load chapters and render
    loadModernChapters();
    
    // Auto-detect chapters from current document content
    setTimeout(() => {
        detectAndDisplayChaptersFromContent();
    }, 1000);

    // Update stats periodically
    updateChapterStats();
}

function handleChapterSearch() {
    const searchInput = document.getElementById('chapter-search');
    const clearBtn = document.querySelector('.clear-search');
    
    if (!searchInput || !clearBtn) return;
    
    const searchTerm = searchInput.value;
    
    if (searchTerm) {
        clearBtn.style.display = 'block';
    } else {
        clearBtn.style.display = 'none';
    }

    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        filterChapters(searchTerm);
    }, 300);
}

function clearSearch() {
    const searchInput = document.getElementById('chapter-search');
    const clearBtn = document.querySelector('.clear-search');
    
    if (searchInput) searchInput.value = '';
    if (clearBtn) clearBtn.style.display = 'none';
    filterChapters('');
}

function filterChapters(searchTerm) {
    const filteredChapters = searchTerm ? 
        chapters.filter(chapter => 
            chapter.title && chapter.title.toLowerCase().includes(searchTerm.toLowerCase())
        ) : chapters;
    
    renderModernChapterList(filteredChapters);
}

function loadModernChapters() {
    if (!projectId) {
        // If no project, try to detect chapters from current content
        detectAndDisplayChaptersFromContent();
        return;
    }
    
    fetch('/writer/projects/' + projectId + '/chapters/list/')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                chapters = data.chapters || [];
                updateChapterCount();
                renderModernChapterList();
                updateChapterStats();
                
                // If no chapters exist, try to detect from content
                if (chapters.length === 0) {
                    setTimeout(() => {
                        detectAndDisplayChaptersFromContent();
                    }, 500);
                }
            } else {
                console.error('Error loading chapters:', data.error);
                detectAndDisplayChaptersFromContent();
            }
        })
        .catch(error => {
            console.error('Error loading chapters:', error);
            detectAndDisplayChaptersFromContent();
        });
}

function renderModernChapterList(chaptersToRender = chapters) {
    const container = document.getElementById('chapter-list-modern');
    const emptyState = document.getElementById('empty-chapters');
    
    if (!container) {
        console.warn('Chapter list container not found');
        return;
    }
    
    if (!chaptersToRender || chaptersToRender.length === 0) {
        if (emptyState) {
            emptyState.style.display = 'block';
            container.innerHTML = '';
            container.appendChild(emptyState);
        }
        return;
    }
    
    if (emptyState) emptyState.style.display = 'none';
    container.innerHTML = '';
    
    chaptersToRender.forEach((chapter, index) => {
        const chapterElement = createModernChapterItem(chapter, index);
        container.appendChild(chapterElement);
    });
}

function createModernChapterItem(chapter, index) {
    const item = document.createElement('div');
    item.className = 'chapter-item-modern';
    item.setAttribute('data-chapter-id', chapter.id);
    
    if (currentChapterId === chapter.id) {
        item.classList.add('active');
    }
    
    // Calculate word count (rough estimate)
    const wordCount = chapter.content ? chapter.content.split(/\s+/).filter(w => w.length > 0).length : 0;
    const readTime = Math.max(1, Math.ceil(wordCount / 200)); // ~200 words per minute
    
    item.innerHTML = `
        <div class="chapter-content-modern">
            <div class="chapter-number-modern" onclick="editChapterNumber(${chapter.id}, ${index + 1})" title="💡 Click to reorder: Change this number to move the chapter to a different position">
                <span class="number-display">${index + 1}</span>
                <input class="number-input" type="number" min="1" max="${chapters.length}" value="${index + 1}" style="display: none;">
            </div>
            <div class="chapter-details-modern">
                <h4 class="chapter-title-modern">${escapeHtml(chapter.title || 'Untitled Chapter')}</h4>
                <div class="chapter-stats-modern">
                    <div class="stat-modern">
                        <i class="fas fa-file-alt"></i>
                        <span>${wordCount} words</span>
                    </div>
                    <div class="stat-modern">
                        <i class="fas fa-clock"></i>
                        <span>${readTime} min read</span>
                    </div>
                    <div class="stat-modern">
                        <i class="fas fa-calendar"></i>
                        <span>${formatDate(chapter.created_at || new Date())}</span>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Add click handler for opening chapter
    item.addEventListener('click', (e) => {
        openModernChapter(chapter.id);
    });
    
    return item;
}

function createNewChapter() {
    if (!projectId) {
        showNotification('Chapter creation requires a project context', 'error');
        return;
    }
    
    // Create a more modern dialog
    const title = prompt('Chapter Title:', 'New Chapter');
    if (!title) return;
    
    const formData = new FormData();
    formData.append('title', title);
    formData.append('order', chapters.length + 1);
    
    // Get CSRF token - try multiple methods
    let csrfToken = null;
    const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
    const csrfMeta = document.querySelector('meta[name=csrf-token]');
    const csrfCookie = document.cookie.split(';').find(row => row.startsWith('csrftoken='));
    
    if (csrfInput && csrfInput.value) {
        csrfToken = csrfInput.value;
    } else if (csrfMeta) {
        csrfToken = csrfMeta.getAttribute('content');
    } else if (csrfCookie) {
        csrfToken = csrfCookie.split('=')[1];
    }
    
    if (csrfToken) {
        formData.append('csrfmiddlewaretoken', csrfToken);
    } else {
        console.warn('CSRF token not found');
    }
    
    // Show loading state
    showNotification('Creating chapter...', 'info');
    
    console.log('Creating chapter with project ID:', projectId);
    console.log('CSRF token found:', !!csrfToken);
    
    // Add project ID to form data for session-based endpoint
    formData.append('project', projectId);
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData,
        credentials: 'same-origin' // Ensure cookies are sent
    })
    .then(response => {
        console.log('Response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Response data:', data);
        if (data.success) {
            // Create chapter object from response
            const newChapter = {
                id: data.chapter_id,
                title: title,
                content: '',
                created_at: new Date().toISOString()
            };
            
            chapters.push(newChapter);
            updateChapterCount();
            renderModernChapterList();
            updateChapterStats();
            showNotification(data.message || 'Chapter created successfully!', 'success');
            
            // Auto-open the new chapter
            setTimeout(() => openModernChapter(data.chapter_id), 500);
        } else {
            showNotification('Error creating chapter: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter:', error);
        if (error.message.includes('401')) {
            console.log('Authentication failed - checking session...');
            // Test if user is still authenticated with a simple request
            fetch('/writer/', { credentials: 'same-origin' })
                .then(response => {
                    if (response.status === 401) {
                        showNotification('Session expired - please refresh the page and log in again', 'error');
                    } else {
                        showNotification('Authentication error - please try again', 'error');
                    }
                })
                .catch(() => {
                    showNotification('Network error - please check your connection and try again', 'error');
                });
        } else if (error.message.includes('403')) {
            showNotification('Permission denied - you may not have access to this project', 'error');
        } else {
            showNotification('Error creating chapter: ' + error.message, 'error');
        }
    });
}

function openModernChapter(chapterId) {
    // Save current content before switching
    if (currentChapterId && quill) {
        saveDocument(false);
    }
    
    // Update active state
    document.querySelectorAll('.chapter-item-modern').forEach(item => {
        item.classList.remove('active');
    });
    
    const activeItem = document.querySelector(`[data-chapter-id="${chapterId}"]`);
    if (activeItem) {
        activeItem.classList.add('active');
    }
    
    // Load chapter content
    const chapter = chapters.find(c => c.id === chapterId);
    if (chapter) {
        currentChapterId = chapterId;
        currentDocumentId = chapterId;
        
        // Update document title
        const titleInput = document.getElementById('document-title');
        if (titleInput) {
            titleInput.value = chapter.title || 'Untitled Chapter';
        }
        
        // Load content into editor
        if (quill && chapter.content) {
            const cleanedContent = cleanContentForQuill(chapter.content);
            if (cleanedContent.includes('<')) {
                quill.root.innerHTML = cleanedContent;
            } else {
                quill.setText(cleanedContent);
            }
        }
        
        showNotification(`Opened: ${chapter.title}`, 'success');
    }
}

function editModernChapter(chapterId) {
    const chapter = chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    
    const newTitle = prompt('Edit Chapter Title:', chapter.title);
    if (!newTitle || newTitle === chapter.title) return;
    
    // Update locally first for immediate feedback
    chapter.title = newTitle;
    renderModernChapterList();
    
    // Then update server
    const formData = new FormData();
    formData.append('title', newTitle);
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    if (csrfToken) formData.append('csrfmiddlewaretoken', csrfToken.value);
    
    fetch('/writer/chapters/' + chapterId + '/edit/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('Chapter title updated!', 'success');
        } else {
            // Revert on error
            loadModernChapters();
            showNotification('Error updating chapter title', 'error');
        }
    })
    .catch(error => {
        console.error('Error updating chapter:', error);
        loadModernChapters();
        showNotification('Error updating chapter title', 'error');
    });
}

function deleteModernChapter(chapterId) {
    const chapter = chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    
    if (!confirm(`Are you sure you want to delete "${chapter.title}"?\n\nThis action cannot be undone.`)) {
        return;
    }
    
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    const headers = {
        'Content-Type': 'application/json'
    };
    if (csrfToken) headers['X-CSRFToken'] = csrfToken.value;
    
    fetch('/writer/chapters/' + chapterId + '/delete/', {
        method: 'POST',
        headers: headers
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            chapters = chapters.filter(c => c.id !== chapterId);
            updateChapterCount();
            renderModernChapterList();
            updateChapterStats();
            showNotification('Chapter deleted', 'success');
            
            // If this was the current chapter, clear the editor
            if (currentChapterId === chapterId) {
                currentChapterId = null;
                if (quill) {
                    quill.setText('');
                }
                const titleInput = document.getElementById('document-title');
                if (titleInput) titleInput.value = '';
            }
        } else {
            showNotification('Error deleting chapter', 'error');
        }
    })
    .catch(error => {
        console.error('Error deleting chapter:', error);
        showNotification('Error deleting chapter', 'error');
    });
}

function duplicateChapter(chapterId) {
    const chapter = chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    
    const newTitle = prompt('Title for duplicated chapter:', chapter.title + ' (Copy)');
    if (!newTitle) return;
    
    const formData = new FormData();
    formData.append('title', newTitle);
    formData.append('content', chapter.content || '');
    formData.append('project', projectId); // Add project ID
    formData.append('order', chapters.length + 1);
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    if (csrfToken) formData.append('csrfmiddlewaretoken', csrfToken.value);
    
    showNotification('Duplicating chapter...', 'info');
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData,
        credentials: 'same-origin'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            chapters.push(data.chapter);
            updateChapterCount();
            renderModernChapterList();
            updateChapterStats();
            showNotification('Chapter duplicated successfully!', 'success');
        } else {
            showNotification('Error duplicating chapter', 'error');
        }
    })
    .catch(error => {
        console.error('Error duplicating chapter:', error);
        showNotification('Error duplicating chapter', 'error');
    });
}

function toggleChapterManager() {
    const manager = document.getElementById('chapter-manager');
    const icon = document.getElementById('manager-toggle-icon');
    
    if (!manager || !icon) return;
    
    manager.classList.toggle('collapsed');
    
    if (manager.classList.contains('collapsed')) {
        icon.className = 'fas fa-chevron-right';
        // Add click listener to the collapsed panel itself
        manager.onclick = function(e) {
            // Only expand if clicking on the collapsed area, not the toggle button
            if (!e.target.closest('.toggle-btn')) {
                toggleChapterManager();
            }
        };
    } else {
        icon.className = 'fas fa-chevron-left';
        // Remove the click listener when expanded
        manager.onclick = null;
    }
}

function updateChapterCount() {
    const countElement = document.getElementById('chapter-count');
    if (countElement) {
        countElement.textContent = chapters.length;
    }
}

function updateChapterStats() {
    const totalWords = chapters.reduce((total, chapter) => {
        const wordCount = chapter.content ? chapter.content.split(/\s+/).filter(w => w.length > 0).length : 0;
        return total + wordCount;
    }, 0);
    
    const avgChapterLength = chapters.length > 0 ? Math.round(totalWords / chapters.length) : 0;
    
    const totalWordsElement = document.getElementById('total-words');
    const avgLengthElement = document.getElementById('avg-chapter-length');
    
    if (totalWordsElement) {
        totalWordsElement.textContent = formatNumber(totalWords);
    }
    
    if (avgLengthElement) {
        avgLengthElement.textContent = formatNumber(avgChapterLength);
    }
}

function showEmptyState() {
    const container = document.getElementById('chapter-list-modern');
    const emptyState = document.getElementById('empty-chapters');
    
    if (!container || !emptyState) return;
    
    container.innerHTML = '';
    emptyState.style.display = 'block';
    container.appendChild(emptyState);
    updateChapterCount();
}

// Utility functions
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function formatDate(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now - date;
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (days === 0) return 'Today';
    if (days === 1) return 'Yesterday';
    if (days < 7) return `${days} days ago`;
    
    return date.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric',
        year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
    });
}

function formatNumber(num) {
    if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
}

// Smart Header Formatting Handler
let pendingChapterText = null;

function handleSmartHeaderFormat(value, quillInstance) {
    const selection = quillInstance.getSelection();
    
    if (value === 2 && selection && selection.length > 0) {
        // Capture the selected text before any formatting
        const selectedText = quillInstance.getText(selection.index, selection.length).trim();
        
        if (selectedText.length > 2 && selectedText.length < 100) {
            // Store the text for chapter creation
            pendingChapterText = selectedText;
            
            // Instead of H2 block format, apply custom inline formatting
            // that makes it look like a heading but doesn't affect the whole paragraph
            quillInstance.formatText(selection.index, selection.length, {
                'bold': true,
                'size': '18px',
                'color': '#1a73e8'
            });
            
            // Create chapter immediately
            setTimeout(() => {
                if (pendingChapterText && projectId) {
                    createChapterFromH2(pendingChapterText);
                    pendingChapterText = null;
                }
            }, 100);
            
            // Show user feedback
            showNotification(`Creating chapter: "${selectedText}"...`, 'info');
        } else if (selectedText.length > 0) {
            // Text too long/short, just make it bold and larger
            quillInstance.formatText(selection.index, selection.length, {
                'bold': true,
                'size': '16px'
            });
            showNotification('Text formatted as heading (too long/short for chapter)', 'info');
        } else {
            // No selection, apply H2 to current line normally
            quillInstance.format('header', 2);
        }
    } else {
        // Handle other header values normally
        quillInstance.format('header', value);
    }
}

// Remove the old checkForSmartChapterCreation function
function checkForSmartChapterCreation(delta) {
    // This function is no longer needed as we handle it in the toolbar handler
    return;
}

function createChapterFromH2(chapterTitle) {
    if (!projectId) {
        showNotification('Chapter creation requires a project context', 'info');
        return;
    }
    
    // Check if a chapter with this title already exists
    const existingChapter = chapters.find(c => 
        c.title && c.title.toLowerCase() === chapterTitle.toLowerCase()
    );
    
    if (existingChapter) {
        showNotification(`Chapter "${chapterTitle}" already exists`, 'info');
        return;
    }
    
    const formData = new FormData();
    formData.append('title', chapterTitle);
    formData.append('project', projectId);
    formData.append('content', ''); // Start with empty content
    formData.append('order', chapters.length + 1);
    
    // Get CSRF token - try multiple methods (though this endpoint is csrf_exempt)
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    if (csrfToken && csrfToken.value) {
        formData.append('csrfmiddlewaretoken', csrfToken.value);
    }
    
    console.log('Creating chapter from H2 formatting:', chapterTitle);
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData,
        credentials: 'same-origin'
    })
    .then(response => {
        console.log('H2 Chapter creation response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('H2 Chapter creation response:', data);
        if (data.success) {
            // Create chapter object for the UI
            const newChapter = {
                id: data.chapter_id,
                title: chapterTitle,
                content: '',
                created_at: new Date().toISOString()
            };
            
            chapters.push(newChapter);
            updateChapterCount();
            renderModernChapterList();
            updateChapterStats();
            
            // Show success with chapter number
            const chapterNumber = chapters.length;
            showNotification(`Chapter ${chapterNumber}: "${chapterTitle}" created!`, 'success');
            
            // Also add a small visual indicator in the text
            setTimeout(() => {
                addChapterMarker(chapterTitle);
            }, 200);
            
            // Highlight the new chapter in the sidebar
            setTimeout(() => {
                const newChapterElement = document.querySelector(`[data-chapter-id="${data.chapter_id}"]`);
                if (newChapterElement) {
                    newChapterElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    newChapterElement.style.animation = 'pulse 1s ease-in-out';
                }
            }, 300);
        } else {
            showNotification('Error creating chapter: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter from H2:', error);
        if (error.message.includes('401')) {
            showNotification('Authentication error - please refresh the page', 'error');
        } else if (error.message.includes('403')) {
            showNotification('Permission denied', 'error');
        } else {
            showNotification('Error creating chapter', 'error');
        }
    });
}

// Chapter Marker Function
function addChapterMarker(chapterTitle) {
    if (!quill) return;
    
    const text = quill.getText();
    const titleIndex = text.indexOf(chapterTitle);
    
    if (titleIndex !== -1) {
        // Add a small chapter icon after the title
        const endIndex = titleIndex + chapterTitle.length;
        
        // Insert a small chapter marker
        quill.insertText(endIndex, ' 📖', {
            'color': '#667eea',
            'size': '12px'
        });
    }
}

// Chapter Number Editing Functions
function editChapterNumber(chapterId, currentPosition) {
    const chapterElement = document.querySelector(`[data-chapter-id="${chapterId}"]`);
    if (!chapterElement) return;
    
    const numberOrb = chapterElement.querySelector('.chapter-number-modern');
    const numberDisplay = numberOrb.querySelector('.number-display');
    const numberInput = numberOrb.querySelector('.number-input');
    
    if (!numberOrb || !numberDisplay || !numberInput) return;
    
    // Switch to edit mode
    numberOrb.classList.add('editing');
    numberDisplay.style.display = 'none';
    numberInput.style.display = 'block';
    numberInput.value = currentPosition;
    numberInput.focus();
    numberInput.select();
    
    // Set max value to current number of chapters
    numberInput.max = chapters.length;
    
    // Handle input completion
    const finishEdit = (save = true) => {
        numberOrb.classList.remove('editing');
        numberDisplay.style.display = 'block';
        numberInput.style.display = 'none';
        
        if (save) {
            const newPosition = parseInt(numberInput.value);
            
            if (newPosition && newPosition >= 1 && newPosition <= chapters.length && newPosition !== currentPosition) {
                reorderChapterByNumber(chapterId, currentPosition, newPosition);
            } else if (newPosition !== currentPosition) {
                showNotification('Invalid position. Please enter a number between 1 and ' + chapters.length, 'error');
            }
        }
    };
    
    // Event listeners
    numberInput.addEventListener('blur', () => finishEdit(true));
    numberInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            finishEdit(true);
        } else if (e.key === 'Escape') {
            e.preventDefault();
            finishEdit(false);
        }
    });
    
    // Prevent chapter opening when clicking on the number
    numberOrb.addEventListener('click', (e) => {
        e.stopPropagation();
    });
}

function reorderChapterByNumber(chapterId, oldPosition, newPosition) {
    if (oldPosition === newPosition) return;
    
    const chapter = chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    
    // Show loading state
    showNotification(`Moving "${chapter.title}" from position ${oldPosition} to ${newPosition}...`, 'info');
    
    // Update local array immediately for UI feedback
    const oldIndex = oldPosition - 1;
    const newIndex = newPosition - 1;
    
    // Remove from old position and insert at new position
    const movedChapter = chapters.splice(oldIndex, 1)[0];
    chapters.splice(newIndex, 0, movedChapter);
    
    // Update UI immediately
    renderModernChapterList();
    
    // Send to server
    const orderData = chapters.map((ch, index) => ({ 
        id: ch.id, 
        order: index + 1 
    }));
    
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    const headers = {
        'Content-Type': 'application/json'
    };
    if (csrfToken) headers['X-CSRFToken'] = csrfToken.value;
    
    fetch('/writer/chapters/reorder/', {
        method: 'POST',
        headers: headers,
        body: JSON.stringify({ chapters: orderData }),
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            showNotification(`✅ "${chapter.title}" moved to position ${newPosition}!`, 'success');
            
            // Highlight the moved chapter
            setTimeout(() => {
                const movedElement = document.querySelector(`[data-chapter-id="${chapterId}"]`);
                if (movedElement) {
                    movedElement.style.animation = 'pulse 1s ease-in-out';
                    movedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 300);
        } else {
            throw new Error(data.error || 'Reorder failed');
        }
    })
    .catch(error => {
        console.error('Error reordering chapters:', error);
        showNotification('Error reordering chapters. Refreshing...', 'error');
        
        // Reload chapters on error to restore correct order
        setTimeout(() => {
            loadModernChapters();
        }, 1500);
    });
}

// ===== INNOVATIVE FLOATING ACTION BUBBLE SYSTEM =====

let floatingBubble = null;
let bubbleTimeout = null;
let lastSelection = null;

function initializeFloatingActionBubble() {
    // Create the floating action bubble
    createFloatingBubble();
    
    // Debounce selection change handling
    let selectionDebounce = null;
    
    // Listen for text selection changes with debouncing
    document.addEventListener('selectionchange', function() {
        clearTimeout(selectionDebounce);
        selectionDebounce = setTimeout(handleSelectionChange, 100);
    });
    
    // Hide bubble when clicking elsewhere
    document.addEventListener('click', function(e) {
        if (floatingBubble && !floatingBubble.contains(e.target)) {
            hideFloatingBubble();
        }
    });
}

function createFloatingBubble() {
    floatingBubble = document.createElement('div');
    floatingBubble.className = 'floating-action-bubble';
    floatingBubble.innerHTML = `
        <div class="bubble-container">
            <div class="bubble-content">
                <div class="bubble-header">
                    <span class="bubble-title">✨ Create Chapter</span>
                    <div class="bubble-close" onclick="hideFloatingBubble()">×</div>
                </div>
                <div class="bubble-actions">
                    <button class="bubble-btn primary" onclick="createChapterFromBubble()">
                        <i class="fas fa-book-open"></i>
                        <span>Make Chapter</span>
                    </button>
                    <button class="bubble-btn secondary" onclick="highlightAsImportant()">
                        <i class="fas fa-star"></i>
                        <span>Mark Important</span>
                    </button>
                    <button class="bubble-btn accent" onclick="addToOutline()">
                        <i class="fas fa-list-alt"></i>
                        <span>Add to Outline</span>
                    </button>
                </div>
                <div class="bubble-suggestion" id="bubble-suggestion"></div>
            </div>
            <div class="bubble-arrow"></div>
        </div>
    `;
    
    document.body.appendChild(floatingBubble);
}

function handleSelectionChange() {
    clearTimeout(bubbleTimeout);
    
    // Small delay to let selection settle
    bubbleTimeout = setTimeout(() => {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText && selectedText.length > 2 && selectedText.length < 200) {
            // Check if selection is within the editor
            const range = selection.getRangeAt(0);
            const editorElement = document.getElementById('docs-editor');
            
            if (editorElement && editorElement.contains(range.commonAncestorContainer)) {
                showFloatingBubble(selectedText, range);
            }
        } else {
            hideFloatingBubble();
        }
    }, 100);
}

function showFloatingBubble(selectedText, range) {
    if (!floatingBubble || !projectId) return;
    
    lastSelection = { text: selectedText, range: range };
    
    // Position the bubble near the selection
    const rect = range.getBoundingClientRect();
    const bubbleRect = floatingBubble.getBoundingClientRect();
    
    let top = rect.bottom + window.scrollY + 10;
    let left = rect.left + window.scrollX + (rect.width / 2) - 150; // Center bubble
    
    // Keep bubble in viewport
    const maxLeft = window.innerWidth - 300;
    const minLeft = 10;
    left = Math.max(minLeft, Math.min(maxLeft, left));
    
    // If bubble would go below viewport, show it above selection
    if (top + 120 > window.innerHeight + window.scrollY) {
        top = rect.top + window.scrollY - 120 - 10;
    }
    
    floatingBubble.style.left = left + 'px';
    floatingBubble.style.top = top + 'px';
    
    // Update suggestion based on text analysis
    updateBubbleSuggestion(selectedText);
    
    // Show with animation
    floatingBubble.classList.add('visible');
    floatingBubble.style.animation = 'bubbleSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards';
}

function hideFloatingBubble() {
    if (!floatingBubble) return;
    
    floatingBubble.style.animation = 'bubbleSlideOut 0.2s cubic-bezier(0.4, 0, 0.2, 1) forwards';
    
    setTimeout(() => {
        floatingBubble.classList.remove('visible');
    }, 200);
}

function updateBubbleSuggestion(selectedText) {
    const suggestionElement = document.getElementById('bubble-suggestion');
    if (!suggestionElement) return;
    
    // Smart analysis of selected text
    const analysis = analyzeTextForChapter(selectedText);
    
    if (analysis.isGoodChapterTitle) {
        suggestionElement.innerHTML = `
            <div class="suggestion-good">
                <i class="fas fa-check-circle"></i>
                <span>"${selectedText}" looks like a great chapter title!</span>
            </div>
        `;
    } else if (analysis.tooLong) {
        suggestionElement.innerHTML = `
            <div class="suggestion-warning">
                <i class="fas fa-exclamation-triangle"></i>
                <span>Text is a bit long for a chapter title (${selectedText.length} chars)</span>
            </div>
        `;
    } else if (analysis.tooShort) {
        suggestionElement.innerHTML = `
            <div class="suggestion-warning">
                <i class="fas fa-info-circle"></i>
                <span>Consider selecting more text for a complete title</span>
            </div>
        `;
    } else {
        suggestionElement.innerHTML = `
            <div class="suggestion-neutral">
                <i class="fas fa-lightbulb"></i>
                <span>Selected: "${selectedText.substring(0, 30)}${selectedText.length > 30 ? '...' : ''}"</span>
            </div>
        `;
    }
}

function analyzeTextForChapter(text) {
    const length = text.length;
    const wordCount = text.split(/\s+/).length;
    
    // Check for chapter keywords
    const chapterKeywords = /(chapter|part|section|book|episode|prologue|epilogue)/i;
    const hasChapterKeywords = chapterKeywords.test(text);
    
    // Check if it's title case or sentence case
    const words = text.split(/\s+/);
    const capitalizedWords = words.filter(word => /^[A-Z]/.test(word)).length;
    const isTitleCase = capitalizedWords / words.length > 0.5;
    
    return {
        isGoodChapterTitle: length >= 5 && length <= 60 && (isTitleCase || hasChapterKeywords),
        tooLong: length > 60,
        tooShort: length < 5,
        hasKeywords: hasChapterKeywords,
        isTitleCase: isTitleCase,
        wordCount: wordCount
    };
}

function createChapterFromBubble() {
    if (!lastSelection || !projectId) {
        showNotification('No text selected', 'error');
        return;
    }
    
    const chapterTitle = lastSelection.text;
    hideFloatingBubble();
    
    // Check if chapter already exists
    const existingChapter = chapters.find(c => 
        c.title && c.title.toLowerCase() === chapterTitle.toLowerCase()
    );
    
    if (existingChapter) {
        showNotification(`Chapter "${chapterTitle}" already exists`, 'warning');
        return;
    }
    
    // Create chapter with floating success animation
    createChapterWithAnimation(chapterTitle);
}

function createChapterWithAnimation(chapterTitle) {
    const formData = new FormData();
    formData.append('title', chapterTitle);
    formData.append('project', projectId);
    formData.append('content', '');
    formData.append('order', chapters.length + 1);
    
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    if (csrfToken && csrfToken.value) {
        formData.append('csrfmiddlewaretoken', csrfToken.value);
    }
    
    // Show floating loading animation
    showFloatingSuccess('Creating chapter...', 'loading');
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData,
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return response.json();
    })
    .then(data => {
        if (data.success) {
            const newChapter = {
                id: data.chapter_id,
                title: chapterTitle,
                content: '',
                created_at: new Date().toISOString()
            };
            
            chapters.push(newChapter);
            updateChapterCount();
            renderModernChapterList();
            updateChapterStats();
            
            // Show success animation
            showFloatingSuccess(`Chapter "${chapterTitle}" created!`, 'success');
            
            // Highlight selected text in editor
            if (lastSelection && lastSelection.range) {
                highlightTextInEditor(lastSelection.range, 'chapter-created');
            }
        } else {
            throw new Error(data.error || 'Unknown error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter:', error);
        showFloatingSuccess('Error creating chapter', 'error');
    });
}

function highlightAsImportant() {
    if (!lastSelection) return;
    
    const range = lastSelection.range;
    const selection = window.getSelection();
    
    // Create a highlight span
    const highlight = document.createElement('span');
    highlight.className = 'important-highlight';
    highlight.style.cssText = 'background: linear-gradient(135deg, #ffd700, #ffed4e); color: #333; padding: 2px 4px; border-radius: 3px; font-weight: 500;';
    
    try {
        range.surroundContents(highlight);
        showFloatingSuccess('⭐ Marked as important!', 'success');
    } catch (e) {
        console.log('Could not highlight text:', e);
        showFloatingSuccess('Could not highlight complex selection', 'warning');
    }
    
    hideFloatingBubble();
}

function addToOutline() {
    if (!lastSelection) return;
    
    const text = lastSelection.text;
    
    // Add to a simple outline system (could be expanded)
    const outline = JSON.parse(localStorage.getItem('documentOutline') || '[]');
    outline.push({
        text: text,
        timestamp: new Date().toISOString(),
        type: 'outline-item'
    });
    
    localStorage.setItem('documentOutline', JSON.stringify(outline));
    
    showFloatingSuccess(`📝 Added "${text.substring(0, 20)}..." to outline!`, 'success');
    hideFloatingBubble();
}

function showFloatingSuccess(message, type = 'success') {
    const toast = document.createElement('div');
    toast.className = `floating-toast floating-toast-${type}`;
    toast.textContent = message;
    
    toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 25px;
        color: white;
        font-weight: 500;
        z-index: 10001;
        animation: toastSlideIn 0.3s ease-out forwards;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    `;
    
    if (type === 'success') {
        toast.style.background = 'linear-gradient(135deg, #4caf50, #45a049)';
    } else if (type === 'error') {
        toast.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';
    } else if (type === 'warning') {
        toast.style.background = 'linear-gradient(135deg, #ff9800, #f57c00)';
    } else if (type === 'loading') {
        toast.style.background = 'linear-gradient(135deg, #2196f3, #1976d2)';
    }
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.animation = 'toastSlideOut 0.3s ease-in forwards';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

function highlightTextInEditor(range, className) {
    try {
        const highlight = document.createElement('span');
        highlight.className = className;
        highlight.style.cssText = 'background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2)); border-radius: 3px; animation: highlightPulse 2s ease-in-out;';
        
        range.surroundContents(highlight);
        
        // Remove highlight after animation
        setTimeout(() => {
            const parent = highlight.parentNode;
            while (highlight.firstChild) {
                parent.insertBefore(highlight.firstChild, highlight);
            }
            parent.removeChild(highlight);
        }, 2000);
    } catch (e) {
        console.log('Could not highlight text in editor:', e);
    }
}

// ===== END FLOATING ACTION BUBBLE SYSTEM =====

// ===== FLOATING COMPANION TOOLBAR =====

let floatingCompanion = null;
let companionLastScrollY = 0;
let companionTargetY = 100;
let companionCurrentY = 100;
let companionAnimation = null;
let selectedText = '';
let selectedRange = null;

function initializeFloatingCompanion() {
    createFloatingCompanion();
    
    // Set initial position based on header height with extra buffer
    const header = document.querySelector('.docs-header');
    const headerHeight = header ? header.offsetHeight + 40 : 100; // 40px buffer to avoid buttons
    companionTargetY = headerHeight;
    companionCurrentY = headerHeight;
    
    // Listen for scroll to update position
    window.addEventListener('scroll', updateCompanionPosition);
    window.addEventListener('resize', updateCompanionPosition);
    
    // Debounce companion selection handling
    let companionSelectionDebounce = null;
    
    // Listen for text selection with debouncing
    document.addEventListener('selectionchange', function() {
        clearTimeout(companionSelectionDebounce);
        companionSelectionDebounce = setTimeout(handleCompanionSelection, 150);
    });
    
    // Initial position
    updateCompanionPosition();
}

function createFloatingCompanion() {
    floatingCompanion = document.createElement('div');
    floatingCompanion.className = 'floating-companion';
    floatingCompanion.innerHTML = `
        <div class="companion-body">
            <div class="companion-header">
                <div class="companion-avatar">📝</div>
                <div class="companion-title">Writing Friend</div>
                <button class="companion-minimize" onclick="toggleCompanion()">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            
            <div class="companion-content">
                <!-- Page Navigation Section Removed -->
                
                <!-- Quick Chapter Creation -->
                <div class="companion-section">
                    <div class="section-title">
                        <i class="fas fa-book-open"></i>
                        <span>Quick Chapter</span>
                    </div>
                    <button class="companion-btn chapter-btn" onclick="quickCreateChapter()" title="Create chapter from selection">
                        <i class="fas fa-plus-circle"></i>
                        <span>Make Chapter</span>
                        <div class="btn-shimmer"></div>
                    </button>
                </div>

                <!-- Auto Chapter Detection -->
                <div class="companion-section">
                    <div class="section-title">
                        <i class="fas fa-magic"></i>
                        <span>Auto Detection</span>
                    </div>
                    <button class="companion-btn highlight-btn" onclick="autoDetectChapters()" title="Automatically detect and create chapters">
                        <i class="fas fa-search"></i>
                        <span>Detect Chapters</span>
                        <div class="btn-shimmer"></div>
                    </button>
                    <div id="detection-results" style="display: none; margin-top: 8px;">
                        <div class="detection-preview">
                            <div id="detected-chapters-list"></div>
                            <div class="detection-actions" style="margin-top: 8px; display: flex; gap: 4px;">
                                <button class="companion-btn accent" onclick="createDetectedChapters()" style="flex: 1; font-size: 10px; padding: 4px 6px;">
                                    <i class="fas fa-check"></i>
                                    Create
                                </button>
                                <button class="companion-btn" onclick="hideDetectionResults()" style="flex: 1; font-size: 10px; padding: 4px 6px;">
                                    <i class="fas fa-times"></i>
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Format Tools -->
                <div class="companion-section">
                    <div class="section-title">
                        <i class="fas fa-paint-brush"></i>
                        <span>Format</span>
                    </div>
                    <div class="format-tools">
                        <button class="format-btn" onclick="companionFormat('bold')" title="Bold">
                            <i class="fas fa-bold"></i>
                        </button>
                        <button class="format-btn" onclick="companionFormat('italic')" title="Italic">
                            <i class="fas fa-italic"></i>
                        </button>
                        <button class="format-btn" onclick="companionFormat('underline')" title="Underline">
                            <i class="fas fa-underline"></i>
                        </button>
                        <button class="format-btn" onclick="companionFormat('strike')" title="Strikethrough">
                            <i class="fas fa-strikethrough"></i>
                        </button>
                    </div>
                    <div class="format-tools">
                        <button class="format-btn" onclick="companionFormat('header', 2)" title="Heading 2">
                            <span class="format-text">H2</span>
                        </button>
                        <button class="format-btn" onclick="companionFormat('header', 3)" title="Heading 3">
                            <span class="format-text">H3</span>
                        </button>
                        <button class="format-btn" onclick="companionFormat('blockquote')" title="Quote">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button class="format-btn" onclick="companionFormat('code-block')" title="Code">
                            <i class="fas fa-code"></i>
                        </button>
                    </div>
                    <div class="format-tools">
                        <button class="format-btn" onclick="companionAlign('left')" title="Align Left">
                            <i class="fas fa-align-left"></i>
                        </button>
                        <button class="format-btn" onclick="companionAlign('center')" title="Align Center">
                            <i class="fas fa-align-center"></i>
                        </button>
                        <button class="format-btn" onclick="companionAlign('right')" title="Align Right">
                            <i class="fas fa-align-right"></i>
                        </button>
                        <button class="format-btn" onclick="companionAlign('justify')" title="Justify">
                            <i class="fas fa-align-justify"></i>
                        </button>
                    </div>
                    <div class="format-tools">
                        <button class="format-btn" onclick="centerSelectedText()" title="Center Selected Text as Title">
                            <i class="fas fa-align-center"></i>
                            <span style="font-size: 8px; margin-left: 2px;">Title</span>
                        </button>
                        <button class="format-btn" onclick="toggleAutoCentering()" title="Toggle Auto-Centering Titles">
                            <i class="fas fa-magic" id="auto-center-toggle-icon"></i>
                            <span style="font-size: 8px; margin-left: 2px;">Auto</span>
                        </button>
                    </div>
                    <div class="format-tools">
                        <button class="format-btn" onclick="companionList('bullet')" title="Bullet List">
                            <i class="fas fa-list-ul"></i>
                        </button>
                        <button class="format-btn" onclick="companionList('ordered')" title="Numbered List">
                            <i class="fas fa-list-ol"></i>
                        </button>
                        <button class="format-btn" onclick="companionIndent('-1')" title="Decrease Indent">
                            <i class="fas fa-outdent"></i>
                        </button>
                        <button class="format-btn" onclick="companionIndent('+1')" title="Increase Indent">
                            <i class="fas fa-indent"></i>
                        </button>
                    </div>
                    <div class="format-tools">
                        <button class="format-btn" onclick="companionColor()" title="Text Color">
                            <i class="fas fa-palette"></i>
                        </button>
                        <button class="format-btn" onclick="companionFormat('clean')" title="Clear Formatting">
                            <i class="fas fa-eraser"></i>
                        </button>
                        <button class="format-btn" onclick="companionUndo()" title="Undo">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button class="format-btn" onclick="companionRedo()" title="Redo">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Smart Actions -->
                <div class="companion-section">
                    <div class="section-title">
                        <i class="fas fa-magic"></i>
                        <span>Smart Tools</span>
                    </div>
                    <button class="companion-btn highlight-btn" onclick="highlightSelection()" title="Highlight important text">
                        <i class="fas fa-highlighter"></i>
                        <span>Highlight</span>
                        <div class="btn-shimmer"></div>
                    </button>
                    <button class="companion-btn outline-btn" onclick="addToOutlineFromCompanion()" title="Add to outline">
                        <i class="fas fa-list-alt"></i>
                        <span>Add to Outline</span>
                        <div class="btn-shimmer"></div>
                    </button>
                </div>
                
                <!-- Selection Info -->
                <div class="companion-section selection-info">
                    <div class="section-title">
                        <i class="fas fa-info-circle"></i>
                        <span>Selection</span>
                    </div>
                    <div class="selection-stats" id="selection-stats">
                        <div class="stat-item">
                            <span class="stat-value" id="selected-words">0</span>
                            <span class="stat-label">words</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="selected-chars">0</span>
                            <span class="stat-label">chars</span>
                        </div>
                    </div>
                    <div class="selection-preview" id="selection-preview">
                        Select text to see options
                    </div>
                </div>
                
                <!-- Version Control - Moved to bottom -->
                <div class="companion-section">
                    <div class="section-title">
                        <i class="fas fa-history"></i>
                        <span>Version Control</span>
                    </div>
                    <div class="version-controls">
                        <button class="companion-btn version-btn" onclick="saveCurrentVersion()" title="Save current version">
                            <i class="fas fa-save"></i>
                            <span>Save Version</span>
                        </button>
                        <select class="version-select" id="version-select" onchange="loadSelectedVersion()" title="Load a version">
                            <option value="">Select version...</option>
                        </select>
                        <button class="format-btn" onclick="refreshVersionList()" title="Refresh versions">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Companion Mood -->
            <div class="companion-mood" id="companion-mood">
                <div class="mood-face">😊</div>
                <div class="mood-text">Ready to help!</div>
            </div>
        </div>
        
        <!-- Floating particles -->
        <div class="companion-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
    `;
    
    document.body.appendChild(floatingCompanion);
}

function updateCompanionPosition() {
    if (!floatingCompanion) return;
    
    const scrollY = window.scrollY;
    const windowHeight = window.innerHeight;
    const companionHeight = floatingCompanion.offsetHeight;
    
    // Get the actual header height dynamically with buffer to avoid buttons
    const header = document.querySelector('.docs-header');
    const headerHeight = header ? header.offsetHeight + 40 : 100; // 40px buffer to avoid header buttons
    
    // Target position: stay below header buttons, always visible in viewport
    const minY = headerHeight;
    const maxY = windowHeight - companionHeight - 50;
    const preferredY = scrollY + headerHeight;
    
    companionTargetY = Math.max(minY, Math.min(maxY, preferredY));
    
    // Smooth animation to target position
    if (companionAnimation) {
        cancelAnimationFrame(companionAnimation);
    }
    
    animateCompanionToPosition();
}

function animateCompanionToPosition() {
    const diff = companionTargetY - companionCurrentY;
    
    if (Math.abs(diff) < 1) {
        companionCurrentY = companionTargetY;
        floatingCompanion.style.transform = `translateY(${companionCurrentY}px)`;
        return;
    }
    
    companionCurrentY += diff * 0.1; // Smooth easing
    floatingCompanion.style.transform = `translateY(${companionCurrentY}px)`;
    
    companionAnimation = requestAnimationFrame(animateCompanionToPosition);
}

function handleCompanionSelection() {
    const selection = window.getSelection();
    selectedText = selection.toString().trim();
    
    if (selectedText.length > 0) {
        selectedRange = selection.getRangeAt(0);
        
        // Check if selection is in editor
        const editorElement = document.getElementById('docs-editor');
        if (editorElement && editorElement.contains(selectedRange.commonAncestorContainer)) {
            updateCompanionWithSelection(selectedText);
        } else {
            clearCompanionSelection();
        }
    } else {
        clearCompanionSelection();
    }
}

function updateCompanionWithSelection(text) {
    if (!floatingCompanion) return;
    
    // Update selection stats
    const words = text.split(/\s+/).filter(w => w.length > 0).length;
    const chars = text.length;
    
    document.getElementById('selected-words').textContent = words;
    document.getElementById('selected-chars').textContent = chars;
    
    // Update preview
    const preview = document.getElementById('selection-preview');
    const previewText = text.length > 50 ? text.substring(0, 50) + '...' : text;
    preview.innerHTML = `"<em>${previewText}</em>"`;
    
    // Update companion mood based on selection
    updateCompanionMood(text);
    
    // Highlight companion
    floatingCompanion.classList.add('has-selection');
    
    // Animate chapter button if good for chapter
    const chapterBtn = floatingCompanion.querySelector('.chapter-btn');
    if (isGoodChapterTitle(text)) {
        chapterBtn.classList.add('pulse');
    } else {
        chapterBtn.classList.remove('pulse');
    }
}

function clearCompanionSelection() {
    if (!floatingCompanion) return;
    
    document.getElementById('selected-words').textContent = '0';
    document.getElementById('selected-chars').textContent = '0';
    document.getElementById('selection-preview').textContent = 'Select text to see options';
    
    floatingCompanion.classList.remove('has-selection');
    floatingCompanion.querySelector('.chapter-btn').classList.remove('pulse');
    
    // Reset mood
    updateCompanionMood('');
}

function updateCompanionMood(text) {
    const moodElement = document.getElementById('companion-mood');
    const moodFace = moodElement.querySelector('.mood-face');
    const moodText = moodElement.querySelector('.mood-text');
    
    if (!text) {
        moodFace.textContent = '😊';
        moodText.textContent = 'Ready to help!';
    } else if (text.length < 5) {
        moodFace.textContent = '🤔';
        moodText.textContent = 'Select more text';
    } else if (isGoodChapterTitle(text)) {
        moodFace.textContent = '🌟';
        moodText.textContent = 'Great chapter title!';
    } else if (text.length > 100) {
        moodFace.textContent = '😅';
        moodText.textContent = 'That\'s a lot of text!';
    } else {
        moodFace.textContent = '😍';
        moodText.textContent = 'Nice selection!';
    }
}

function isGoodChapterTitle(text) {
    const length = text.length;
    const wordCount = text.split(/\s+/).length;
    const chapterKeywords = /(chapter|part|section|book|episode)/i;
    const hasKeywords = chapterKeywords.test(text);
    const words = text.split(/\s+/);
    const capitalizedWords = words.filter(word => /^[A-Z]/.test(word)).length;
    const isTitleCase = capitalizedWords / words.length > 0.5;
    
    return length >= 5 && length <= 60 && (isTitleCase || hasKeywords) && wordCount <= 8;
}

function quickCreateChapter() {
    if (!selectedText || selectedText.length < 3) {
        showCompanionNotification('Select some text first to create a chapter!', 'warning');
        return;
    }
    
    if (!projectId) {
        showCompanionNotification('Chapter creation requires a project context', 'error');
        return;
    }
    
    // Check for existing chapter
    const existingChapter = chapters.find(c => 
        c.title && c.title.toLowerCase() === selectedText.toLowerCase()
    );
    
    if (existingChapter) {
        showCompanionNotification(`Chapter "${selectedText}" already exists!`, 'warning');
        return;
    }
    
    // Create chapter
    const formData = new FormData();
    formData.append('title', selectedText);
    formData.append('project', projectId);
    formData.append('content', '');
    formData.append('order', chapters.length + 1);
    
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
    if (csrfToken && csrfToken.value) {
        formData.append('csrfmiddlewaretoken', csrfToken.value);
    }
    
    showCompanionNotification('Creating chapter...', 'info');
    companionCelebrate('working');
    
    fetch('/writer/chapters/create/', {
        method: 'POST',
        body: formData,
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return response.json();
    })
    .then(data => {
        if (data.success) {
            const newChapter = {
                id: data.chapter_id,
                title: selectedText,
                content: '',
                created_at: new Date().toISOString()
            };
            
            chapters.push(newChapter);
            updateChapterCount();
            renderModernChapterList();
            updateChapterStats();
            
            showCompanionNotification(`Chapter "${selectedText}" created! 🎉`, 'success');
            companionCelebrate('success');
            
            // Highlight the text in editor
            if (selectedRange) {
                highlightTextInEditor(selectedRange, 'chapter-created');
            }
        } else {
            throw new Error(data.error || 'Unknown error');
        }
    })
    .catch(error => {
        console.error('Error creating chapter:', error);
        showCompanionNotification('Error creating chapter', 'error');
        companionCelebrate('error');
    });
}

function companionFormat(format, value = true) {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    const selection = quill.getSelection();
    if (!selection || selection.length === 0) {
        showCompanionNotification('Select text to format', 'warning');
        return;
    }
    
    if (format === 'header') {
        // Use our smart header handler for H2
        if (value === 2) {
            handleSmartHeaderFormat(2, quill);
        } else {
            quill.format('header', value);
        }
    } else {
        quill.format(format, value);
    }
    
    showCompanionNotification(`Applied ${format} formatting!`, 'success');
    companionCelebrate('format');
}

// MLA Pagination Functions
function togglePagination() {
    console.log('Toggle pagination called - pagination is disabled');
    
    // Pagination is permanently disabled
    paginationEnabled = false;
    const paginationSection = document.getElementById('pagination-section');
    const toggleIcon = document.getElementById('pagination-toggle-icon');
    
    console.log('Pagination section found:', !!paginationSection);
    console.log('Toggle icon found:', !!toggleIcon);
    
    // Show notification that pagination is disabled
    showNotification('📄 Pagination has been permanently disabled', 'info');
    console.log('Pagination disabled permanently');
}

function calculatePages() {
    if (!quill || !paginationEnabled) {
        console.log('Calculate pages skipped - quill:', !!quill, 'paginationEnabled:', paginationEnabled);
        return;
    }
    
    const content = quill.getText();
    const contentLength = content.length;
    
    console.log('Calculating pages for content length:', contentLength);
    
    if (contentLength === 0) {
        pages = [''];
        totalPages = 1;
        updatePageInfo();
        return;
    }
    
    pages = [];
    let currentPageContent = '';
    let currentCharCount = 0;
    
    // Split content by paragraphs to find natural breaking points
    const paragraphs = content.split('\n');
    
    for (let para of paragraphs) {
        // Check if adding this paragraph would exceed page limit
        if (currentCharCount + para.length > mlaCharactersPerPage && currentPageContent.length > 0) {
            // Find last sentence boundary in current content
            const lastPeriod = currentPageContent.lastIndexOf('.');
            const lastExclamation = currentPageContent.lastIndexOf('!');
            const lastQuestion = currentPageContent.lastIndexOf('?');
            const lastSentence = Math.max(lastPeriod, lastExclamation, lastQuestion);
            
            if (lastSentence > currentPageContent.length * 0.7) {
                // Break at sentence boundary if it's not too early in the page
                pages.push(currentPageContent.substring(0, lastSentence + 1).trim());
                currentPageContent = currentPageContent.substring(lastSentence + 1).trim() + '\n' + para;
            } else {
                // Break at paragraph boundary
                pages.push(currentPageContent.trim());
                currentPageContent = para;
            }
            currentCharCount = currentPageContent.length;
        } else {
            currentPageContent += (currentPageContent ? '\n' : '') + para;
            currentCharCount += para.length + (currentPageContent === para ? 0 : 1);
        }
    }
    
    // Add the last page
    if (currentPageContent.trim()) {
        pages.push(currentPageContent.trim());
    }
    
    totalPages = Math.max(1, pages.length);
    currentPage = Math.min(currentPage, totalPages);
    updatePageInfo();
}

function navigateToPage(direction) {
    if (!paginationEnabled) return;
    
    if (direction === -1 && currentPage > 1) {
        currentPage--;
    } else if (direction === 1 && currentPage < totalPages) {
        currentPage++;
    } else {
        return; // No navigation needed
    }
    
    showCurrentPage();
    updatePageInfo();
    companionCelebrate('working');
}

function showCurrentPage() {
    if (!quill || !paginationEnabled) return;
    
    const pageContent = pages[currentPage - 1] || '';
    
    // Set the content (text-change events will fire normally)
    quill.setText(pageContent);
    
    // Add page break indicator
    addPageBreakIndicator();
}

function showAllContent() {
    if (!quill) return;
    
    const fullContent = pages.join('\n\n');
    
    // Set the full content (text-change events will fire normally)
    quill.setText(fullContent);
    
    // Remove page break indicators
    removePageBreakIndicators();
}

function updatePageInfo() {
    document.getElementById('current-page').textContent = currentPage;
    document.getElementById('total-pages').textContent = totalPages;
    
    // Update footer page numbers
    const footerCurrentPage = document.getElementById('footer-current-page');
    const footerTotalPages = document.getElementById('footer-total-pages');
    
    if (footerCurrentPage) footerCurrentPage.textContent = currentPage;
    if (footerTotalPages) footerTotalPages.textContent = totalPages;
    
    // Show/hide page number indicator
    const pageDisplay = document.getElementById('page-number-display');
    if (pageDisplay) {
        if (paginationEnabled && totalPages > 1) {
            pageDisplay.style.display = 'block';
        } else {
            pageDisplay.style.display = 'none';
        }
    }
}

// Quick page navigation dialog
function showPageNavigationDialog() {
    if (!paginationEnabled) return;
    
    const pageNum = prompt(`Go to page (1-${totalPages}):`, currentPage);
    const targetPage = parseInt(pageNum);
    
    if (targetPage && targetPage >= 1 && targetPage <= totalPages && targetPage !== currentPage) {
        currentPage = targetPage;
        showCurrentPage();
        updatePageInfo();
        companionCelebrate('success');
        showCompanionNotification(`Jumped to page ${targetPage}!`, 'success');
    }
}

function addPageBreakIndicator() {
    const editor = document.querySelector('.ql-editor');
    if (editor && paginationEnabled) {
        // Remove existing indicators
        removePageBreakIndicators();
        
        // Add page indicator at the top
        const indicator = document.createElement('div');
        indicator.className = 'page-break';
        indicator.setAttribute('data-page-number', currentPage);
        editor.insertBefore(indicator, editor.firstChild);
    }
}

function removePageBreakIndicators() {
    const indicators = document.querySelectorAll('.page-break');
    indicators.forEach(indicator => indicator.remove());
}

// Version Control Functions
function saveCurrentVersion() {
    if (!quill) return;
    
    const content = quill.getText();
    const title = document.getElementById('document-title')?.value || 'Untitled';
    const timestamp = new Date().toISOString();
    const versionName = `${title} - ${new Date().toLocaleString()}`;
    
    if (currentChapterId) {
        // Save chapter version
        const formData = new FormData();
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
        formData.append('content', content);
        formData.append('version_name', versionName);
        
        fetch(`/writer/chapters/${currentChapterId}/versions/save/`, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showCompanionNotification('Version saved successfully!', 'success');
                refreshVersionList();
                companionCelebrate('success');
            } else {
                showCompanionNotification('Failed to save version', 'error');
            }
        })
        .catch(error => {
            console.error('Version save error:', error);
            showCompanionNotification('Error saving version', 'error');
        });
    } else if (currentDocumentId) {
        // Save document version
        const formData = new FormData();
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
        formData.append('content', content);
        formData.append('version_name', versionName);
        
        fetch(`/writer/documents/${currentDocumentId}/versions/save/`, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showCompanionNotification('Version saved successfully!', 'success');
                refreshVersionList();
                companionCelebrate('success');
            } else {
                showCompanionNotification('Failed to save version', 'error');
            }
        })
        .catch(error => {
            console.error('Version save error:', error);
            showCompanionNotification('Error saving version', 'error');
        });
    }
}

function refreshVersionList() {
    const select = document.getElementById('version-select');
    if (!select) return;
    
    // Clear existing options
    select.innerHTML = '<option value="">Select version...</option>';
    
    const endpoint = currentChapterId 
        ? `/writer/chapters/${currentChapterId}/versions/`
        : currentDocumentId 
        ? `/writer/documents/${currentDocumentId}/versions/`
        : null;
    
    if (!endpoint) return;
    
    fetch(endpoint)
    .then(response => response.json())
    .then(data => {
        if (data.success && data.versions) {
            data.versions.forEach(version => {
                const option = document.createElement('option');
                option.value = version.id;
                option.textContent = version.version_name || new Date(version.created_at).toLocaleString();
                select.appendChild(option);
            });
        }
    })
    .catch(error => {
        console.error('Error loading versions:', error);
    });
}

function loadSelectedVersion() {
    const select = document.getElementById('version-select');
    const versionId = select?.value;
    
    if (!versionId || !quill) return;
    
    const endpoint = currentChapterId 
        ? `/writer/chapters/${currentChapterId}/versions/${versionId}/restore/`
        : currentDocumentId 
        ? `/writer/documents/${currentDocumentId}/versions/${versionId}/restore/`
        : null;
    
    if (!endpoint) return;
    
    const formData = new FormData();
    formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch(endpoint, {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.content) {
            quill.setText(data.content);
            if (paginationEnabled) {
                calculatePages();
                showCurrentPage();
            }
            showCompanionNotification('Version restored successfully!', 'success');
            companionCelebrate('success');
            
            // Update title if provided
            if (data.title && document.getElementById('document-title')) {
                document.getElementById('document-title').value = data.title;
            }
        } else {
            showCompanionNotification('Failed to restore version', 'error');
        }
    })
    .catch(error => {
        console.error('Version restore error:', error);
        showCompanionNotification('Error restoring version', 'error');
    });
    
    // Reset select
    select.value = '';
}

// Keyboard navigation for pagination
document.addEventListener('keydown', function(e) {
    if (!paginationEnabled) return;
    
    // Alt + Arrow keys for page navigation
    if (e.altKey) {
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            navigateToPage(-1);
        } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            navigateToPage(1);
        }
    }
});

// Performance optimization for large documents
function optimizeEditorPerformance() {
    if (!quill) return;
    
    const contentLength = quill.getText().length;
    
    // For very large documents (>10000 characters), enable performance optimizations
    if (contentLength > 10000) {
        console.log('Enabling performance optimizations for large document');
        
        // Reduce history stack size for better performance
        if (quill.history) {
            quill.history.options.maxStack = 100;
        }
        
        // Pagination suggestions removed
        
        // Auto-enable pagination removed
    }
    
    // Memory management for very large documents
    if (contentLength > 50000) {
        console.log('Applying aggressive optimizations for extremely large document');
        
        // Force pagination removed
    }
}

// Debounce function for performance
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Create debounced version of performance optimization
const debouncedOptimizePerformance = debounce(optimizeEditorPerformance, 1000);

// Create debounced version of chapter detection
const debouncedChapterDetection = debounce(() => {
    if (quill && quill.getText().length > 500) {
        detectAndDisplayChaptersFromContent();
    }
}, 3000);

// Auto-centering feature
let autoCenteringEnabled = false;

// Auto-center titles function
function autoCenterTitles() {
    if (!quill) return;
    
    const editor = quill.root;
    const paragraphs = editor.querySelectorAll('p, h1, h2, h3, h4, h5, h6');
    
    paragraphs.forEach(element => {
        const text = element.textContent.trim();
        
        // Check if it looks like a title and isn't already centered
        if (isTitleCandidate(text) && element.style.textAlign !== 'center') {
            // Apply center alignment
            element.style.textAlign = 'center';
            element.style.fontWeight = 'bold';
            
            // Add subtle styling to make it look more like a title
            if (text.length < 50) {
                element.style.fontSize = '1.2em';
                element.style.marginTop = '1.5em';
                element.style.marginBottom = '1em';
            }
            
            console.log('Auto-centered title:', text);
        }
    });
}

// Check if text looks like a title
function isTitleCandidate(text) {
    if (!text || text.length === 0) return false;
    
    // Title characteristics:
    const length = text.length;
    const hasCapitals = /[A-Z]/.test(text);
    const endsWithPeriod = text.endsWith('.');
    const isAllCaps = text === text.toUpperCase() && text.length > 1;
    const hasColonOrQuestion = text.includes(':') || text.includes('?');
    const startsWithCapital = /^[A-Z]/.test(text);
    
    // Common title words
    const titleWords = [
        'chapter', 'part', 'section', 'introduction', 'conclusion',
        'epilogue', 'prologue', 'foreword', 'preface', 'appendix',
        'summary', 'overview', 'review', 'analysis', 'discussion'
    ];
    
    const containsTitleWord = titleWords.some(word => 
        text.toLowerCase().includes(word)
    );
    
    // Title patterns
    const chapterPattern = /^(chapter|part|section)\s+\d+/i;
    const romanNumeralPattern = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII)\./;
    const numberedPattern = /^\d+\./;
    
    // Decision logic
    if (length > 100) return false; // Too long to be a title
    if (length < 3) return false;   // Too short
    
    // Strong indicators it's a title
    if (isAllCaps && length < 50) return true;
    if (chapterPattern.test(text)) return true;
    if (romanNumeralPattern.test(text)) return true;
    if (numberedPattern.test(text) && length < 60) return true;
    if (containsTitleWord && startsWithCapital && length < 80) return true;
    
    // Medium indicators
    if (hasCapitals && startsWithCapital && !endsWithPeriod && length < 50) {
        return true;
    }
    
    if (hasColonOrQuestion && startsWithCapital && length < 70) {
        return true;
    }
    
    return false;
}

// Manual title centering function for companion
function centerSelectedText() {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    const selection = quill.getSelection();
    if (!selection || selection.length === 0) {
        showCompanionNotification('Please select text to center', 'warning');
        return;
    }
    
    // Apply center alignment
    quill.formatText(selection.index, selection.length, 'align', 'center');
    quill.formatText(selection.index, selection.length, 'bold', true);
    
    showCompanionNotification('Text centered and bolded!', 'success');
    companionCelebrate('format');
}

// Toggle auto-centering feature
function toggleAutoCentering() {
    autoCenteringEnabled = !autoCenteringEnabled;
    
    if (autoCenteringEnabled) {
        showCompanionNotification('✨ Auto-centering enabled! Titles will be centered automatically.', 'success');
        setTimeout(() => {
            autoCenterTitles();
        }, 500);
    } else {
        showCompanionNotification('📝 Auto-centering disabled.', 'info');
    }
    
    // Update toggle button icon
    const toggleIcon = document.getElementById('auto-center-toggle-icon');
    if (toggleIcon) {
        toggleIcon.className = autoCenteringEnabled ? 'fas fa-magic' : 'fas fa-align-left';
    }
    
    companionCelebrate('format');
}

// Create debounced version of auto-center for performance
const debouncedAutoCenterTitles = debounce(() => {
    if (autoCenteringEnabled) {
        autoCenterTitles();
    }
}, 1000);

// Auto-detected chapters (virtual chapters) - variable declared later in Chapter Auto-Detection Functions

// Atticus.io style chapter detection using Django backend
function detectAndDisplayChaptersFromContent() {
    if (!quill) {
        console.log('Quill not ready for chapter detection');
        return;
    }
    
    const content = quill.getText();
    if (!content || content.trim().length < 100) {
        console.log('Not enough content for chapter detection');
        showEmptyState();
        return;
    }
    
    console.log('Detecting chapters using Django backend...');
    
    // Send text to Django backend for chapter detection
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
    
    fetch('/writer/api/detect-chapters/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            text: content
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.chapters) {
            if (data.chapters.length > 1) {
                // Show detected chapters in the sidebar
                detectedChapters = data.chapters;
                showDetectedChapters(data.chapters);
                showChapterDetectionNotification(data.chapters.length);
            } else {
                // Show single document view
                showSingleDocumentView(content);
            }
        } else {
            console.log('No chapters detected:', data.error);
            showSingleDocumentView(content);
        }
    })
    .catch(error => {
        console.error('Chapter detection error:', error);
        // Fallback to client-side detection
        const detectedChapterData = detectChaptersInContentClientSide(content);
        if (detectedChapterData.length > 1) {
            detectedChapters = detectedChapterData;
            showDetectedChapters(detectedChapterData);
            showChapterDetectionNotification(detectedChapterData.length);
        } else {
            showSingleDocumentView(content);
        }
    });
}

// Fallback client-side detection (renamed to avoid confusion)
function detectChaptersInContentClientSide(content) {
    if (!content) return [];
    
    const chapterPatterns = [
        // Pattern 1: "Chapter X" or "Chapter One"
        { 
            regex: /(?:^|\n)\s*(?:chapter|ch\.?)\s+([0-9]+|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)(?:\s*[:-]?\s*(.+?))?\s*(?:\n|$)/gi,
            confidence: 0.9,
            type: 'chapter'
        },
        // Pattern 2: "Part I" or "Section 1"
        {
            regex: /(?:^|\n)\s*(?:part|section)\s+([0-9]+|i|ii|iii|iv|v|vi|vii|viii|ix|x|one|two|three|four|five)(?:\s*[:-]?\s*(.+?))?\s*(?:\n|$)/gi,
            confidence: 0.8,
            type: 'section'
        },
        // Pattern 3: Numbered headings "1. Title" or "1) Title"
        {
            regex: /(?:^|\n)\s*([0-9]+)[.):]\s*([A-Z][^\n]{3,80})\s*(?:\n|$)/g,
            confidence: 0.7,
            type: 'numbered'
        },
        // Pattern 4: ALL CAPS titles (common in books)
        {
            regex: /(?:^|\n)\s*([A-Z][A-Z\s,.:!?-]{8,60})\s*(?:\n|$)/g,
            confidence: 0.6,
            type: 'caps'
        }
    ];
    
    const allMatches = [];
    
    chapterPatterns.forEach((pattern, patternIndex) => {
        let match;
        while ((match = pattern.regex.exec(content)) !== null) {
            const position = match.index;
            const fullMatch = match[0].trim();
            
            // Extract title based on pattern type
            let title = '';
            if (pattern.type === 'chapter') {
                const number = match[1];
                const subtitle = match[2] || '';
                title = subtitle ? `Chapter ${number}: ${subtitle.trim()}` : `Chapter ${number}`;
            } else if (pattern.type === 'section') {
                const number = match[1];
                const subtitle = match[2] || '';
                const sectionType = fullMatch.toLowerCase().includes('part') ? 'Part' : 'Section';
                title = subtitle ? `${sectionType} ${number}: ${subtitle.trim()}` : `${sectionType} ${number}`;
            } else if (pattern.type === 'numbered') {
                title = match[2].trim();
            } else if (pattern.type === 'caps') {
                title = match[1].trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
            }
            
            allMatches.push({
                position: position,
                title: title || 'Untitled Chapter',
                fullMatch: fullMatch,
                confidence: pattern.confidence,
                type: pattern.type
            });
        }
    });
    
    // Sort by position and filter duplicates
    allMatches.sort((a, b) => a.position - b.position);
    
    // Remove overlapping matches
    const filteredMatches = [];
    allMatches.forEach(match => {
        const tooClose = filteredMatches.some(existing => 
            Math.abs(match.position - existing.position) < 50
        );
        
        if (!tooClose && match.confidence >= 0.5) {
            filteredMatches.push(match);
        }
    });
    
    // Create chapter objects
    const chapters = [];
    for (let i = 0; i < filteredMatches.length; i++) {
        const match = filteredMatches[i];
        const nextMatch = filteredMatches[i + 1];
        
        const startPos = match.position;
        const endPos = nextMatch ? nextMatch.position : content.length;
        
        const chapterContent = content.slice(startPos, endPos).trim();
        const wordCount = chapterContent.split(/\s+/).length;
        
        // Skip very short chapters
        if (wordCount < 20) continue;
        
        chapters.push({
            id: `detected_${i + 1}`,
            title: match.title,
            content: chapterContent,
            order: i + 1,
            word_count: wordCount,
            confidence: match.confidence,
            detected_method: match.type,
            is_detected: true,
            position: startPos
        });
    }
    
    return chapters.length > 0 ? chapters : [
        {
            id: 'single_document',
            title: 'Document',
            content: content,
            order: 1,
            word_count: content.split(/\s+/).length,
            confidence: 0.5,
            detected_method: 'single',
            is_detected: true,
            position: 0
        }
    ];
}

function showDetectedChapters(detectedChapterData) {
    const container = document.getElementById('chapter-list-modern');
    const emptyState = document.getElementById('empty-chapters');
    
    if (!container) return;
    
    if (emptyState) emptyState.style.display = 'none';
    container.innerHTML = '';
    
    // Calculate average confidence for display
    const avgConfidence = detectedChapterData.reduce((sum, ch) => sum + ch.confidence, 0) / detectedChapterData.length;
    const confidencePercent = Math.round(avgConfidence * 100);
    
    // Add detection header with enhanced info
    const header = document.createElement('div');
    header.className = 'detected-chapters-header';
    header.innerHTML = `
        <div class="detection-notice">
            <i class="fas fa-robot"></i>
            <span>Auto-detected ${detectedChapterData.length} chapters (${confidencePercent}% confidence)</span>
            <button class="create-chapters-btn" onclick="createDetectedChapters()" title="Create actual chapters">
                <i class="fas fa-plus-circle"></i> Create
            </button>
        </div>
        <div class="detection-stats">
            <small>Total: ${detectedChapterData.reduce((sum, ch) => sum + ch.word_count, 0)} words • Backend processed</small>
        </div>
    `;
    container.appendChild(header);
    
    // Add detected chapters
    detectedChapterData.forEach((chapter, index) => {
        const chapterElement = createDetectedChapterItem(chapter, index);
        container.appendChild(chapterElement);
    });
    
    // Update chapter count
    document.getElementById('chapter-count').textContent = detectedChapterData.length;
}

function createDetectedChapterItem(chapter, index) {
    const element = document.createElement('div');
    element.className = 'chapter-item-modern detected-chapter';
    element.setAttribute('data-chapter-id', chapter.id);
    
    const confidenceColor = chapter.confidence > 0.8 ? '#4caf50' : chapter.confidence > 0.6 ? '#ff9800' : '#f44336';
    
    element.innerHTML = `
        <div class="chapter-number-modern detected-number">
            <div class="number-display">${index + 1}</div>
            <div class="confidence-indicator" style="background: ${confidenceColor}" title="${Math.round(chapter.confidence * 100)}% confidence"></div>
        </div>
        <div class="chapter-content-modern">
            <div class="chapter-title-modern">${chapter.title}</div>
            <div class="chapter-meta-modern">
                <span class="word-count">${chapter.word_count} words</span>
                <span class="detection-method">${chapter.detected_method}</span>
                <span class="confidence-score">${Math.round(chapter.confidence * 100)}%</span>
            </div>
            <div class="chapter-preview">${chapter.content.substring(0, 120)}...</div>
        </div>
        <div class="chapter-actions-modern">
            <button class="action-btn navigate-btn" onclick="navigateToDetectedChapter('${chapter.id}')" title="Go to Chapter">
                <i class="fas fa-eye"></i>
            </button>
            <button class="action-btn split-btn" onclick="splitToChapter('${chapter.id}')" title="Create Chapter">
                <i class="fas fa-scissors"></i>
            </button>
        </div>
    `;
    
    return element;
}

function navigateToDetectedChapter(chapterId) {
    const chapter = detectedChapters.find(c => c.id === chapterId);
    if (!chapter || !quill) return;
    
    // Use the start_position from Django backend detection
    const position = chapter.start_position || 0;
    
    // Set cursor position
    quill.setSelection(position, 0);
    
    // Scroll to position
    quill.scrollIntoView();
    
    // Add navigation animation
    const activeItem = document.querySelector(`[data-chapter-id="${chapterId}"]`);
    if (activeItem) {
        // Remove previous active states
        document.querySelectorAll('.chapter-item-modern').forEach(item => {
            item.classList.remove('active', 'navigating');
        });
        
        // Add active and animation
        activeItem.classList.add('active', 'navigating');
        
        // Remove animation after completion
        setTimeout(() => {
            activeItem.classList.remove('navigating');
        }, 600);
    }
    
    showCompanionNotification(`🎯 Navigated to: ${chapter.title} (${chapter.word_count} words)`, 'success');
}

function showChapterDetectionNotification(chapterCount) {
    showCompanionNotification(
        `📚 Detected ${chapterCount} chapters! Use the chapter manager to navigate or create actual chapters.`,
        'info'
    );
}

function showSingleDocumentView(content) {
    const container = document.getElementById('chapter-list-modern');
    const emptyState = document.getElementById('empty-chapters');
    
    if (!container) return;
    
    if (emptyState) emptyState.style.display = 'none';
    container.innerHTML = `
        <div class="single-document-view">
            <div class="document-info">
                <i class="fas fa-file-alt"></i>
                <div class="document-details">
                    <h4>Single Document</h4>
                    <p>${content.split(/\s+/).length} words</p>
                    <small>No chapter structure detected</small>
                </div>
            </div>
            <button class="action-btn" onclick="forceChapterDetection()" title="Try to detect chapters">
                <i class="fas fa-search"></i> Detect Chapters
            </button>
        </div>
    `;
    
    // Update chapter count
    document.getElementById('chapter-count').textContent = '1';
}

function createDetectedChapters() {
    if (!projectId || !detectedChapters.length) {
        showCompanionNotification('❌ Project required to create chapters', 'error');
        return;
    }
    
    showCompanionNotification('🚀 Creating chapters from AI detection...', 'info');
    
    // Create each chapter via API
    const createPromises = detectedChapters.map((chapter, index) => {
        const formData = new FormData();
        formData.append('title', chapter.title);
        formData.append('content', chapter.content);
        formData.append('order', index + 1);
        formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
        
        return fetch(`/writer/projects/${projectId}/chapters/create/`, {
            method: 'POST',
            body: formData
        }).then(response => response.json());
    });
    
    Promise.all(createPromises)
        .then(results => {
            const successful = results.filter(r => r.success).length;
            if (successful > 0) {
                showCompanionNotification(`✅ Successfully created ${successful} chapters from AI detection!`, 'success');
                // Reload the chapter list
                loadModernChapters();
                // Celebrate the success
                companionCelebrate('success');
            } else {
                showCompanionNotification('❌ Failed to create chapters', 'error');
            }
        })
        .catch(error => {
            console.error('Error creating chapters:', error);
            showCompanionNotification('❌ Error creating chapters', 'error');
        });
}

function forceChapterDetection() {
    showCompanionNotification('🔍 Analyzing document for chapters...', 'info');
    setTimeout(() => {
        detectAndDisplayChaptersFromContent();
    }, 500);
}

// Chapter detection functions
function showChapterDetectionDialog(data, file) {
    const dialog = createChapterDialog(data, file);
    document.body.appendChild(dialog);
    dialog.style.display = 'flex';
}

function createChapterDialog(data, file) {
    const dialog = document.createElement('div');
    dialog.className = 'chapter-detection-modal';
    dialog.innerHTML = `
        <div class="chapter-dialog-backdrop"></div>
        <div class="chapter-dialog-content">
            <div class="chapter-dialog-header">
                <h3><i class="fas fa-book-open"></i> Chapters Detected!</h3>
                <button class="chapter-dialog-close" onclick="closeChapterDialog()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="chapter-dialog-body">
                <div class="chapter-detection-summary">
                    <p><strong>${data.filename || file.name}</strong> contains <strong>${data.chapter_count}</strong> chapters with ${data.total_words} total words.</p>
                    <div class="confidence-indicator">
                        <span>Detection Confidence: </span>
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${(data.average_confidence * 100)}%"></div>
                        </div>
                        <span>${Math.round(data.average_confidence * 100)}%</span>
                    </div>
                </div>
                
                <div class="chapter-preview-list">
                    <h4>Detected Chapters:</h4>
                    <div class="chapter-items">
                        ${data.chapters.map((chapter, index) => `
                            <div class="chapter-preview-item">
                                <div class="chapter-header">
                                    <strong>${chapter.title}</strong>
                                    <span class="chapter-stats">${chapter.word_count} words</span>
                                </div>
                                <div class="chapter-preview-content">${chapter.preview}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="chapter-actions">
                    <div class="action-group">
                        <button class="chapter-btn primary" onclick="createChaptersFromDocument('${data.filename}')">
                            <i class="fas fa-plus-circle"></i>
                            Create ${data.chapter_count} Chapters
                        </button>
                        <button class="chapter-btn secondary" onclick="loadAsOneDocument()">
                            <i class="fas fa-file-alt"></i>
                            Load as One Document
                        </button>
                    </div>
                    <div class="action-note">
                        <small><i class="fas fa-info-circle"></i> Creating chapters will add them to your current project.</small>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Store data for later use
    dialog._chapterData = data;
    dialog._file = file;
    
    return dialog;
}

function closeChapterDialog() {
    const dialog = document.querySelector('.chapter-detection-modal');
    if (dialog) {
        dialog.remove();
    }
}

function createChaptersFromDocument(filename) {
    const dialog = document.querySelector('.chapter-detection-modal');
    const data = dialog._chapterData;
    const file = dialog._file;
    
    if (!projectId) {
        showCompanionNotification('❌ No project selected. Please select a project first.', 'error');
        return;
    }
    
    // Show loading state
    const createBtn = dialog.querySelector('.primary');
    createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating Chapters...';
    createBtn.disabled = true;
    
    const formData = new FormData();
    formData.append('file', file);
    formData.append('project_id', projectId);
    formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
    
    fetch('/writer/api/create-chapters/', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(result => {
        if (result.success) {
            showCompanionNotification(`✅ Created ${result.chapters.length} chapters successfully!`, 'success');
            closeChapterDialog();
            
            // Refresh chapter list if available
            if (typeof loadChapters === 'function') {
                loadChapters();
            }
            
            // Load the first chapter
            if (result.chapters.length > 0) {
                setTimeout(() => {
                    window.location.href = `/writer/projects/${projectId}/chapters/${result.chapters[0].id}/docs-editor/`;
                }, 1000);
            }
        } else {
            showCompanionNotification('❌ Failed to create chapters: ' + result.error, 'error');
            createBtn.innerHTML = '<i class="fas fa-plus-circle"></i> Create Chapters';
            createBtn.disabled = false;
        }
    })
    .catch(error => {
        console.error('Chapter creation error:', error);
        showCompanionNotification('❌ Error creating chapters', 'error');
        createBtn.innerHTML = '<i class="fas fa-plus-circle"></i> Create Chapters';
        createBtn.disabled = false;
    });
}

function loadAsOneDocument() {
    const dialog = document.querySelector('.chapter-detection-modal');
    const data = dialog._chapterData;
    
    // Load the full content normally
    loadDocumentContent(data);
    closeChapterDialog();
}

// This function will be moved to the top

// Additional formatting functions for the companion toolbar
function companionAlign(alignment) {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    const selection = quill.getSelection();
    if (!selection || selection.length === 0) {
        showCompanionNotification('Select text to align', 'warning');
        return;
    }
    
    quill.format('align', alignment === 'left' ? false : alignment);
    showCompanionNotification(`Text aligned ${alignment}!`, 'success');
    companionCelebrate('format');
}

function companionList(listType) {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    const selection = quill.getSelection();
    if (!selection || selection.length === 0) {
        showCompanionNotification('Select text for list', 'warning');
        return;
    }
    
    quill.format('list', listType);
    showCompanionNotification(`${listType} list applied!`, 'success');
    companionCelebrate('format');
}

function companionIndent(direction) {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    const selection = quill.getSelection();
    if (!selection || selection.length === 0) {
        showCompanionNotification('Select text to indent', 'warning');
        return;
    }
    
    quill.format('indent', direction);
    showCompanionNotification(`Indent ${direction === '+1' ? 'increased' : 'decreased'}!`, 'success');
    companionCelebrate('format');
}

function companionColor() {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    const selection = quill.getSelection();
    if (!selection || selection.length === 0) {
        showCompanionNotification('Select text to color', 'warning');
        return;
    }
    
    // Cycle through common colors
    const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', false];
    const currentFormat = quill.getFormat(selection.index, selection.length);
    const currentColor = currentFormat.color || false;
    const currentIndex = colors.indexOf(currentColor);
    const nextColor = colors[(currentIndex + 1) % colors.length];
    
    quill.format('color', nextColor);
    showCompanionNotification(`Color ${nextColor ? 'applied' : 'removed'}!`, 'success');
    companionCelebrate('format');
}

function companionUndo() {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    quill.history.undo();
    showCompanionNotification('Undone!', 'success');
    companionCelebrate('format');
}

function companionRedo() {
    if (!quill) {
        showCompanionNotification('Editor not ready', 'error');
        return;
    }
    
    quill.history.redo();
    showCompanionNotification('Redone!', 'success');
    companionCelebrate('format');
}

function highlightSelection() {
    if (!selectedRange) {
        showCompanionNotification('Select text to highlight', 'warning');
        return;
    }
    
    try {
        const highlight = document.createElement('span');
        highlight.className = 'companion-highlight';
        highlight.style.cssText = 'background: linear-gradient(135deg, #ffd700, #ffed4e); color: #333; padding: 1px 2px; border-radius: 2px; font-weight: 500;';
        
        selectedRange.surroundContents(highlight);
        showCompanionNotification('⭐ Text highlighted!', 'success');
        companionCelebrate('highlight');
    } catch (e) {
        console.log('Could not highlight complex selection:', e);
        showCompanionNotification('Could not highlight complex selection', 'warning');
    }
}

function addToOutlineFromCompanion() {
    if (!selectedText) {
        showCompanionNotification('Select text to add to outline', 'warning');
        return;
    }
    
    const outline = JSON.parse(localStorage.getItem('documentOutline') || '[]');
    outline.push({
        text: selectedText,
        timestamp: new Date().toISOString(),
        type: 'outline-item'
    });
    
    localStorage.setItem('documentOutline', JSON.stringify(outline));
    
    showCompanionNotification(`Added to outline! 📝`, 'success');
    companionCelebrate('outline');
}

// Chapter Auto-Detection Functions
let detectedChapters = [];

function autoDetectChapters() {
    if (!quill || !projectId) {
        showNotification('Editor or project not ready', 'error');
        return;
    }
    
    // Show loading state
    const detectBtn = document.querySelector('[onclick="autoDetectChapters()"]');
    const originalContent = detectBtn.innerHTML;
    detectBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Detecting...</span>';
    detectBtn.disabled = true;
    
    // Get the current document text
    const documentText = quill.getText();
    
    if (!documentText.trim()) {
        showNotification('No text to analyze', 'warning');
        detectBtn.innerHTML = originalContent;
        detectBtn.disabled = false;
        return;
    }
    
    // Call the backend API
    fetch('/writer/api/detect-chapters/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({
            text: documentText,
            project_id: projectId
        })
    })
    .then(response => response.json())
    .then(data => {
        detectBtn.innerHTML = originalContent;
        detectBtn.disabled = false;
        
        if (data.success) {
            detectedChapters = data.chapters;
            displayDetectionResults(data.chapters);
            highlightChaptersInEditor(data.chapters);
            showNotification(`Detected ${data.total_chapters} chapters!`, 'success');
        } else {
            showNotification('Error detecting chapters: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Chapter detection error:', error);
        showNotification('Error detecting chapters', 'error');
        detectBtn.innerHTML = originalContent;
        detectBtn.disabled = false;
    });
}

function displayDetectionResults(chapters) {
    const resultsDiv = document.getElementById('detection-results');
    const chaptersList = document.getElementById('detected-chapters-list');
    
    if (chapters.length === 0) {
        chaptersList.innerHTML = '<p style="font-size: 10px; color: #666; text-align: center; margin: 8px 0;">No chapters detected</p>';
        resultsDiv.style.display = 'block';
        return;
    }
    
    chaptersList.innerHTML = '';
    
    chapters.forEach((chapter, index) => {
        const chapterDiv = document.createElement('div');
        chapterDiv.className = 'detected-chapter';
        chapterDiv.innerHTML = `
            <div class="chapter-marker">${chapter.number}</div>
            <div class="chapter-preview-title" title="${chapter.title}">${chapter.title}</div>
            <div class="chapter-preview-words">${chapter.content ? chapter.content.split(' ').length : 0}w</div>
        `;
        chaptersList.appendChild(chapterDiv);
    });
    
    resultsDiv.style.display = 'block';
}

function highlightChaptersInEditor(chapters) {
    if (!quill) return;
    
    // Clear existing highlights
    clearChapterHighlights();
    
    const documentText = quill.getText();
    const lines = documentText.split('\n');
    
    chapters.forEach(chapter => {
        // Find the chapter header line
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line && (
                line.toLowerCase().includes(chapter.title.toLowerCase()) ||
                line.match(/^Chapter\s+\d+/i) ||
                line.match(/^#{1,3}\s+/i) ||
                line.match(/^\d+\./i)
            )) {
                // Highlight this line in the editor
                try {
                    const lineIndex = documentText.split('\n').slice(0, i).join('\n').length + (i > 0 ? 1 : 0);
                    const lineLength = line.length;
                    
                    if (lineIndex >= 0 && lineLength > 0) {
                        quill.formatText(lineIndex, lineLength, 'background', 'rgba(102, 126, 234, 0.2)');
                    }
                } catch (e) {
                    console.log('Could not highlight line:', e);
                }
                break;
            }
        }
    });
}

function clearChapterHighlights() {
    if (!quill) return;
    
    try {
        const length = quill.getLength();
        quill.removeFormat(0, length);
    } catch (e) {
        console.log('Could not clear highlights:', e);
    }
}

function createDetectedChapters() {
    if (!detectedChapters || detectedChapters.length === 0) {
        showNotification('No chapters to create', 'warning');
        return;
    }
    
    if (!projectId) {
        showNotification('No project selected', 'error');
        return;
    }
    
    // Show loading state
    const createBtn = document.querySelector('[onclick="createDetectedChapters()"]');
    const originalContent = createBtn.innerHTML;
    createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
    createBtn.disabled = true;
    
    // Ask user if they want to replace existing chapters
    const replaceExisting = confirm(`Create ${detectedChapters.length} chapters?\n\nThis will replace any existing chapters in this project.`);
    
    if (!replaceExisting) {
        createBtn.innerHTML = originalContent;
        createBtn.disabled = false;
        return;
    }
    
    // Call the backend API to create chapters
    fetch('/writer/api/create-chapters-from-detection/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({
            project_id: projectId,
            chapters: detectedChapters,
            replace_existing: true
        })
    })
    .then(response => response.json())
    .then(data => {
        createBtn.innerHTML = originalContent;
        createBtn.disabled = false;
        
        if (data.success) {
            showNotification(`Created ${data.total_created} chapters successfully!`, 'success');
            
            // Hide detection results
            hideDetectionResults();
            
            // Reload the chapter list
            if (typeof loadChapters === 'function') {
                setTimeout(() => loadChapters(), 500);
            }
            
            // Clear highlights
            clearChapterHighlights();
        } else {
            showNotification('Error creating chapters: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        console.error('Chapter creation error:', error);
        showNotification('Error creating chapters', 'error');
        createBtn.innerHTML = originalContent;
        createBtn.disabled = false;
    });
}

function hideDetectionResults() {
    const resultsDiv = document.getElementById('detection-results');
    resultsDiv.style.display = 'none';
    detectedChapters = [];
    clearChapterHighlights();
}

function toggleCompanion() {
    if (!floatingCompanion) return;
    
    floatingCompanion.classList.toggle('minimized');
    
    const icon = floatingCompanion.querySelector('.companion-minimize i');
    if (floatingCompanion.classList.contains('minimized')) {
        icon.className = 'fas fa-chevron-left';
    } else {
        icon.className = 'fas fa-chevron-right';
    }
}

function companionCelebrate(type) {
    if (!floatingCompanion) return;
    
    floatingCompanion.classList.add(`celebrate-${type}`);
    
    setTimeout(() => {
        floatingCompanion.classList.remove(`celebrate-${type}`);
    }, 1000);
}

function showCompanionNotification(message, type = 'info') {
    // Create a small notification near the companion
    const notification = document.createElement('div');
    notification.className = `companion-notification ${type}`;
    notification.textContent = message;
    
    const colors = {
        success: '#4caf50',
        error: '#f44336',
        warning: '#ff9800',
        info: '#2196f3'
    };
    
    notification.style.cssText = `
        position: fixed;
        right: 85px;
        top: ${companionCurrentY + 50}px;
        background: ${colors[type]};
        color: white;
        padding: 8px 12px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: 500;
        z-index: 10001;
        animation: companionNotificationSlide 0.3s ease-out;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'companionNotificationSlide 0.3s ease-in reverse';
        setTimeout(() => notification.remove(), 300);
    }, 2500);
}

// ===== END FLOATING COMPANION TOOLBAR =====

// ===== END MODERN CHAPTER MANAGER FUNCTIONS =====

// Drag and Drop Functions
let draggedElement = null;

function handleDragStart(e) {
    draggedElement = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.outerHTML);
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDrop(e) {
    e.stopPropagation();
    e.preventDefault();
    
    if (draggedElement !== this) {
        const draggedId = parseInt(draggedElement.getAttribute('data-chapter-id'));
        const targetId = parseInt(this.getAttribute('data-chapter-id'));
        
        const draggedIndex = chapters.findIndex(c => c.id === draggedId);
        const targetIndex = chapters.findIndex(c => c.id === targetId);
        
        if (draggedIndex !== -1 && targetIndex !== -1) {
            reorderChapter(draggedId, targetIndex);
        }
    }
    
    return false;
}

function handleDragEnd() {
    this.classList.remove('dragging');
    draggedElement = null;
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

// Add CSRF token to page if not already present
if (!document.querySelector('[name=csrfmiddlewaretoken]')) {
    const csrfInput = document.createElement('input');
    csrfInput.type = 'hidden';
    csrfInput.name = 'csrfmiddlewaretoken';
    csrfInput.value = '{{ csrf_token }}';
    document.body.appendChild(csrfInput);
}

// Debug CSRF token availability
const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
console.log('CSRF token found:', !!csrfToken);
if (csrfToken) {
    console.log('CSRF token value length:', csrfToken.value.length);
}

console.log('JavaScript loaded successfully - VERSION 2.1');
console.log('uploadDocument function available:', typeof window.uploadDocument);
console.log('Current timestamp:', new Date().toISOString());
console.log('Project ID:', typeof projectId !== 'undefined' ? projectId : 'undefined');
</script>
{% endblock %}